import {CircularList} from "../../../components/illus/components/CircularList/CircularList";
import {LinkedList} from "../../../components/illus/components/LinkedList/LinkedList";
import {Sequence} from "../../../components/illus/components/Sequence/Sequence";

<Head>
	<title>Linked Lists</title>
	<meta name={`description`} content={`Notes on linked lists.`}/>
</Head>

# Linked Lists

These notes cover linked lists.

<div className={"outline"}>

1. [Node Definition](#node-definition)
2. [Linked List Definition](#linked-list-definition)
3. [Iterative List Traversal](#iterative-list-traversal)
4. [Length of a Linked List](#length-of-a-linked-list)
	1. [Recursive Implementation](#recursive-implementation)
5. [Deletion](#deletion)
	1. [Left-shifting](#left-shifting)
	2. [Right-shift](#right-shift)
	3. [General Deletion](#general-deletion)
6. [Insertion](#insertion)
7. [Append](#append)
8. [Prepend](#prepend)
9. [Get](#get)
10. [Set](#set)
11. [Insert](#insert)
	1. [Sorted Insertions](#sorted-insertions)
12. [List Reversal](#list-reversal)
	1. [Reverse-by-element](#reverse-by-element)
	2. [Reverse-by-link](#reverse-by-link)
	3. [Recursive List Reversal](#recursive-list-reversal)
13. [Sum of All Elements](#sum-of-all-elements)
	1. [Recursive Approach.](#recursive-approach)
14. [Peak Finder](#peak-finder)
	1. [Recursive Implementation](#recursive-implementation-1)
15. [Valley Finder](#valley-finder)
16. [Searching a Linked List](#searching-a-linked-list)
	1. [Recursive Implementation](#recursive-implementation-2)
17. [Sorted Test](#sorted-test)
18. [Dedupe a Sorted List](#dedupe-a-sorted-list)
19. [Concatenating Lists](#concatenating-lists)
20. [Merging Lists](#merging-lists)
21. [Loop Detection](#loop-detection)

</div>

## Node Definition

Linked lists are created with _nodes_. In languages like C, they're likely created with a struct, and in OOP languages like Java, a class.

<Obj>

${\df{node}}$ is an object ${\sigma(\tx{data},\tx{next}),}$ where ${\tx{data}}$ comparable and ${\tx{next}}$ is a pointer to a node.

- __structure__ ${\df{node}}$ __contains__
	1. ${\df{comparable}~\tx{data}}$
	2. ${\df{node}* ~ \tx{next}}$

</Obj>

Question: How much memory does the node data structure take? We know
that there are two parts to the node, the substantive data and the pointer.
We'll denote the substantive data ${d,}$ and the pointer ${p.}$ We'll also
denote the amount of memory a given node consumes as the function ${m:}$

$$
	m(d) = d + p
$$

Focusing on ${d,}$, the amount of memory consumed by
${d}$ is depends on ${d,}$ by implication, ${d}$'s type, and number of instances of ${d.}$ We'll denote the amount of memory consumed by a value of type ${d}$ as ${t_m,}$ and the number of instances as ${n.}$ Thus, ${d = n \cdot t_d.}$ Placing this in our equation:

$$
	m(d) = (t_m \by n) + p
$$

The value of ${p}$ is a constant, determined by the system's nominal pointer size.

## Linked List Definition

Having defined nodes, we can now define linked lists:

<dfn>

__linked-list__. Given ${i,k \in \nat,}$ a _linked list_ ${L}$ is an object

$$
	(d_0,n:1)_0 \rarr (d_1,n:2)_1 \rarr (d_1,n:3)_2
	\rarr \ldots \rarr (d_{k-2},n:k-1)
	\rarr (d_{k-1},n:\nil)_{k-1}
$$

where each object at ${0 \lt i \lt k-1}$ is a node. Each node at ${i \lt k}$ has a pointer to ${n:i+1,}$ and the node at ${i = k-1}$ has a pointer to ${\nil.}$ We say that ${L}$ has a _length_ ${k,}$ denoted ${\len{(L)},}$ that the node at ${i=0}$ is the _head_ of ${L,}$ and that the node at ${i=k-1}$ is the _tail_ of ${L.}$ We call a linked list of ${k=0}$ the _empty list_.

<Obj>

- __structure__ ${\df{list}}$ __contains__
	1. ${\df{node}^* ~ \tx{data}}$
	2. ${\df{node}^* ~ \tx{tail}}$

</Obj>

</dfn>

Below is the list's constructor.

<Algo>

__~list constructor~__

- __Identifier__: ${\df{new}~\df{list}}$
- __Argument__: A comparable value ${v.}$
- __Image__: The linked list ${L.}$ 

1. __init__ ${\let{n}{\df{malloc}(\df{sizeof}~\df{node})}}$
2. __init__ ${\let{L}{\df{malloc}(\df{sizeof}~\df{list})}}$
3. ${\let{L.\tx{head}}{n}}$
4. ${\let{L.\tx{head}}{L.\tx{head}}}$
5. __return__ ${L}$


</Algo>


## Iterative List Traversal

Suppose we had the following linked list:

$$
	(7 \rarr 5 \rarr 3 \rarr 1).
$$

Now suppose we want to traverse the linked listâ€”i.e., visiting all of the
nodes one at a time. To do so, we employ the facts: First, suppose the
pointer `p` has the pointee `0x200`. This is the address of the first node
storing `7`. Suppose the next node, storing `5`, has the address `0x210`,
which is the pointee of the first node's `next` field.

Thus, to iterate through the linked list, all we must do is execute
`p`, so long as `next` is a nonnull pointer. The general form for iteratively traversing the linked list is as follows:

<Algo>

__~traverse~__

1. __while__ ${(p \neq \nil)}$ __do__
	1. ${p = p.\tx{next}}$
2. __return__ ${p}$

</Algo>

Because of the linked list's self-referential nature, we can also traverse
a linked list recursively.

<Algo>

__~traverse~__

1. __if__ ${(p \neq \nil)}$ __then__ ${\df{traverse}(p.\tx{next})}$
2. __else__ __return__ ${p}$

</Algo>

## Length of a Linked List

One particularly useful operation is to count the number of nodes in a
linked list. This will return the __length__ of a linked list. Say we had
the following linked list:

<LinkedList data={[8, 3, 7, 12, 9]} />

Implementing the linked list above:

```cpp
#include <iostream>

struct Node {
	int data;
	Node* next;
};

Node* newNode(int data) {
	Node* node       = new Node;
				node->data = data;
				node->next = 0;
	return node;
}

int main() {
	Node* root = 0;            // create root
	Node* n1   = newNode(8);   // create nodes
	Node* n2   = newNode(3);
	Node* n3   = newNode(7);
	Node* n4   = newNode(12);
	Node* n5   = newNode(9);

	root     = n1;  // link nodes
	n1->next = n2;
	n2->next = n3;
	n3->next = n4;
	n4->next = n5;
	n5->next = 0;
}
```

There are five nodees in the linked list. Thus, we should expect our count
to return 5.

Counting the number of nodes in a linked list is similar to counting the
number of elements in an array. We can do so iteratively with a __count__
variable:

```cpp
int length(Node* p) {
	int count = 0;
	while(p != 0) {
		count++;
		p = p->next;
	}
	return count;
}
```

The time complexity for this procedure is straightforward. We're traversing
through ${n}$ nodes, incrementing `count`. Hence, we have a time complexity
of ${O(n).}$

And the space complexity? Constant. This is a single function call, and
each of the variables used take a fixed amount of memory. Accordingly, this
approach has a space complexity of ${O(1).}$

### Recursive Implementation

As always, we can implement the same function recursively:

```cpp
	int length(Node* p) {
		if (p == 0) {
			return 0;
		} else {
			return length(p->next) + 1;
		}
	}
```

As with all recursive functions, we start with a base case. The base case
is a list of length ${0}$â€”${P(0),}$ the empty list. If the list contains
one element, then it is a list of length ${1}$â€”${P(1) = P(0) + 1.}$ And if
the list contains two elements, then it is a list of length
${2}$â€”${P(2) = P(1) + 1 = (P(0) + 1) + 1.}$

The function above captures this induction. If the `next` field is ${0,}$
then we've reached the end of a list; the list of length ${0.}$ However, if
the `next` field is not ${0,}$ then the list is not empty. In which case we
must continue until we reach the end of the list.

## Deletion

There are two cases for deleting a node from a linked list:

1. deleting the first node (called __left-shifting__),
2. deleting the last node (called __right-shifting__),
3. deleting a node at a given position ${i.}$

Let's consider each in turn.

### Left-shifting

Suppose we have the following linked list:

<LinkedList data={["root", 8, 7, 3]} />

To left-shift this list, we want to remove the list's head, resulting in:

<LinkedList data={["root", 7, 3]} />

This is a special case of deletion because if we remove the list's head,
then the node immediately after the head must become the new head.
Otherwise, we lose the linked list.

To left-shift, we must have the pointer to the former-head move to the next
node. Once we move this pointer, we no longer have access to the
former-head. It's somewhere in heap memory. And because it's still
somewhere in heap memory, we must _free_ the allocated space. This means
that we must have a pointer to the former-head. Accordingly, left-shifting
a list requires two pointers to the head. One to move to the next node, and
another for deletion.

Illustrating this in pseudocode, first we ensure there's a pointer to the
head:

```nasm
Node* p = head;
```

Then, we have the `head` pointer point to the next node:

```nasm
Node* p = head;
head = head->next;
```

Then, we delete the former head:

```nasm
Node* p = head;
head = head->next;
delete p;
```

As a complete function:

```nasm
lop(Node* list):
	Node* p = list->head;
	list->head = head->next;
	delete p;
```

As we can see, this procedure consists of just three basic steps. Hence,
the algorithm has a time complexity of ${O(1)}$â€”constant time.

Here's an implementation in C++:

```cpp
#include <iostream>

struct Node {
	int data;
	Node* next;
	Node(int newData) {
		data = newData;
		next = NULL;
	}
};

class List {
	Node* head; // This is the first node in the list
	Node* foot; // This is the last node in the list
	public:
		List(int newData) {
			head->data = newData;
			foot       = head;
		}
		List(int arr[], int size) {
			head = new Node(arr[0]);
			foot = head;
			for (int i = 1; i < size; i++) {
				Node* freshNode  = new Node(arr[i]);
							foot->next = freshNode;
							foot       = freshNode;
			}
		}
		void lop() {
			Node* p    = head;
						head = head->next;
			delete p;
		}
		void print() {
			Node* p = head;
			std::cout << "(";
			while (p != NULL) {
				std::cout << p->data << " ";
				p = p->next;
			}
			std::cout << ")\n";
		}
};

int main() {
	int  arr[] = {1,2,3,4,5};
	List list1 = List(arr, 5);
	list1.print();
	list1.lop();
	list1.print();
	return 0;
}
```

```bash
( 1 2 3 4 5 )
( 2 3 4 5 )
```

### Right-shift

The second case for deletion is deleting the _tailend_â€”the very last node
in the list. We traverse the list until the node just before the tailend,
set that node as the new tailend, and nullify its next pointer.

```nasm
List->shift_right() => List:
	if (List->head is null):
		return theList
	else if (List->length is 1):
		List->head = null
		List->tail = null
		List->length--
		return theList
	else:
		let d = List->head
		let t = d
		while (d->next isnt null):
			t = d
			d = d->next
		List->tail = t
		List->tail->next = null
		List->length--
		return List
```

In JavaScript:

```javascript
shiftRight() {
	if (this.#head === null) {
		return this;
	} else if (this.#length === 1) {
		this.#head = null;
		this.#tail = null;
		this.#length--;
		return this;
	} else {
		let d = this.#head;
		let t = d;
		while (d.next) {
			t = d;
			d = d.next;
		}
		this.#tail = t;
		this.#tail.next = null;
		this.#length--;
		return this;
	}
}
```

### General Deletion

Recall that a _tail node_ is any node other than the head. Deleting a tail
node is the second case for deletion. We'll call the tail node deletion
function `removeAt(${i}$)`, where ${i}$ is the position of the node,
starting at ${1.}$ For example, if we have the linked list:

<LinkedList data={["root", 8, 3, 7]} />

executing `deleteNodeAt(2)` results in:

<LinkedList data={["root", 8, 7]} />

The procedure here is fairly straightforward. To delete ${n_2,}$ we must
have two pointers. A pointer to ${n_2,}$ and a pointer immediately before
${n_2,}$ the node ${n_1:}$

<LinkedList data={["root", 8, 3, 7]} />

The two pointers are necessary because we must delete the allocated space
used for ${n_2,}$ the node we seek to delete. This is similar to our
earlier genertal insertion method:

```nasm
fn deleteNodeAt(int position):
	Node* d = head;
	Node* t = head;
	for (int i = 1; i <= position; i++):
		t = d;
		d = d->next;
	t->next = d->next;
	delete d;
```

Here's an implementation in C++:

```cpp
#include <iostream>

struct Node {
	int data;
	Node* next;
	Node(int newData) {
		data = newData;
		next = NULL;
	}
};

class List {
	Node* head;
	Node* foot;
	public:
		List(int data) {
			head = new Node(data);
			foot = head;
		}
		List(int arr[], int size) {
			head = new Node(arr[0]);
			foot = head;
			for (int i = 1; i < size; i++) {
				Node* freshNode = new Node(arr[i]);
				foot->next = freshNode;
				foot = freshNode;
			}
		}
		void deleteNodeAt(int position) {
			Node* d = head;
			Node* t = NULL;
			for (int i = 0; i < position-1; i++) {
				t = d;
				d = d->next;
			}
			t->next = d->next;
			delete d;
		}
		void print() {
			Node* p = head;
			std::cout << "(";
			while (p != NULL) {
				std::cout << p->data << " ";
				p = p->next;
			}
			std::cout << ")\n";
		}
};

int main() {
	int arr[] = {1, 2, 3, 4};
	List listX = List(arr, 4);
	listX.print();
	listX.deleteNodeAt(3);
	listX.print();
	return 0;
}
```

```bash
(1 2 3 4 )
(1 2 4 )
```

The time complexity for this approach depends on which node in the list
we're deleting. If we're deleting the second node, then the time is
constantâ€”${O(1).}$ If, however, we're deleting anywhere else, then we must
traverse over ${n}$ nodes to position our driver and tailer pointers. As
such, the minimimum running time complexity is ${O(1),}$ and maximum time
complexity is ${O(n).}$

We can encapsulate tail node deletion and lopping into the single procedure
of _general deletion_. Doing so is a matter of conditional branching. We'll
call this function `deleteNode(${p}$)`, where ${p}$ is an `int` argument
corresponding to position:

```nasm
fn deleteNode(int p):
	Node* p;
	Node* q;
	if (p == 1):
		p = head;
		head = p->next;
		delete p;
	else:
		p = head;
		q = NULL;
		for (int i = 0; i < p-1 && p; i++):
			q = p;
			p = p->next;
		if (p):
			q->next = p->next;
			delete p;
```

Here's an implementation in C:

```c
void deleteAt(struct Node** head, int index) {
	struct Node* headRef;
	struct Node* previousNode = NULL;
	if (index < 1 || index > length(*head)) {
		printf("Invalid index");
	}
	if (index == 1) {
		headRef = *head;
		*head   = (**head).next;
		free(headRef);
	}
	else {
		headRef = *head;
		for (int i = 0; i < index - 1; i++) {
			previousNode = headRef;
			headRef      = (*headRef).next;
		}
		(*previousNode).next = (*headRef).next;
		free (headRef);
	}
}
```

Testing:

```c
#include <stdlib.h>
#include <stdio.h>

struct Node {
	int data;
	struct Node* next;
};

struct Node* Node(int newData) {
	struct       Node* freshNode = (struct Node*) malloc(sizeof(struct Node));
	(*freshNode).data            = newData;
	(*freshNode).next            = NULL;
	return freshNode;
}

struct Node* List(int arr[], int size) {
	struct Node* head = Node(arr[0]);
	struct Node* foot = head;
	for (int i = 1; i < size; i++) {
		struct  Node* newNode = Node(arr[i]);
		(*foot).next          = newNode;
						foot          = newNode;
	}
	return head;
}

void print(struct Node* p) {
	printf("( ");
	if (p == NULL) {
		printf("empty ");
	} else {
		while (p != NULL) {
			printf("%d ", (*p).data);
			p = (*p).next;
		}
	}
	printf(")\n");
}

int length(struct Node* p) {
	int count = 0;
	if (p == NULL) {
		return count;
	} else {
		while (p != 0) {
			count++;
			p = (*p).next;
		}
		return count;
	}
}

void deleteAt(struct Node** head, int index) {
	struct Node* headRef;
	struct Node* previousNode = NULL;
	if (index < 1 || index > length(*head)) {
		printf("Invalid index");
	}
	if (index == 1) {
		headRef = *head;
		*head   = (**head).next;
		free(headRef);
	}
	else {
		headRef = *head;
		for (int i = 0; i < index - 1; i++) {
			previousNode = headRef;
			headRef      = (*headRef).next;
		}
		(*previousNode).next = (*headRef).next;
		free (headRef);
	}
}

int main() {
	int    arr[]      = {1,2,3,4};
	struct Node* list = List(arr, 4);
	deleteAt(&list, 3);
	print(list);
	deleteAt(&list, 1);
	print(list);
	return 0;
}
```

```bash
( 1 2 4 )
( 2 4 )
```

## Insertion

So far, we've been manually linking nodes. At this point, it would be
helpful to write procedures for inserting new nodes to existing linked
lists. As with any linear data structure, there are three types of
insertions:

1. __Prepending__â€”inserting to the list's head (i.e., inserting a new node
   as the first node).

2. __Interposing__â€”inserting to the list's trunk (i.e., inserting a new
   node somewhere between the first node and the last node).

3. __Appending__â€”inserting to the list's foot (i.e., inserting a new node
   as the last node).

With arrays, the compiler provided indices for us to work with. Linked
lists, however, do not have such indices. But nothing stops us from adding
indices of our own. Once we have indices for the existing nodes, we can
create an abstraction for the indices of insertions. With indices, we see
that there only two cases.

1. Inserting before the first node.
2. Inserting after a given position ${i.}$

For the first case, all we must pass as an argument to some function is
${i = 0.}$ In doing so, the node is inserted at the very beginning. This is
a special case because the head of the list has a unique roleâ€”it is the
only node which is always pointed to from the stack. Lose that connection,
and the linked list is lost.

For the second case, insertion is merely a matter of passing the index. If
we pass as an index ${1,}$ then we're inserting after the first node. If we
pass as an index ${3,}$ then we're inserting after the third node. More
generally: Given a list of ${n}$ nodes, where the first node has an index
${i = 1}$ and the last node has an index ${i = n,}$ passing as an insertion
index ${k}$ will insert the element at ${i = i + 1.}$

All that said, let's now consider the specific procedures.

## Append

Suppose we had the following linked list, called `list1`:

<LinkedList data={["list1", 3]} />

If we write `append(list1, 8)`, we get:

<LinkedList data={["list1", 3, 8]} width={200} />

And when we write `append(list1, 4)`, we get:

<LinkedList data={["list1", 3, 8, 4]} width={215} />

We can implement this procedure by using an additional pointer to the
list's _foot_, or _tailend_â€”the last node in the list. We'll call the
tailend's pointer `t`, the head's pointer `h` and consider the simplest
caseâ€”the empty list. With the empty list, we have the following:

<LinkedList data={["list1", ""]} />

Both the head pointer `h` and the tailend pointer `t` point to the same
node. Why? Because the node in the list above is both the head and the
foot. Once we append a new node, the tailend pointer `t` changes its
pointee to the new node, but the head pointer `h` remains the same.

Now, because the head pointer `h` and the tailend pointer `t` are
additional pointers for a given list, we must ensure that if the list is
emptyâ€”a list with no nodesâ€”`h` and `t` should both be null pointers. To
ensure this, they must both be initially assigned `0`. Only when the list
is made non-emptyâ€”a new node is insertedâ€”do they become nonnull pointers.

```nasm
Node* h = 0;
Node* t = 0;
```

Let's implement this function in pseudocode. First, we'll call this
function `append()`. What might this function's signature look like? Well,
it doesn't return anything, because it's directly inserting into a
particular list. But, it does create a new node. For now, we'll focus on
`int` lists. Hence, our function signature looks like:

```nasm
fn append(int x) -> void
```

With that out of the way, we can now think about how to implement this
function. First, we need to create a new node, with its `data` field
assigned the argument `x`, and its `next` field initially zero:

```nasm
fn append(int x) -> void
	Node* n = newNode(data: x, next: 0)
```

Now we have to consider the cases. Is the list we want to append to the
empty or non-empty list? An implicit corollary question: How do we
determine if a list is empty or non-empty? Well, suppose that every linked
list we create has a pointer called `h`, pointing to the list's head. It
follows then that if `h = 0`, then we have an empty list. Otherwise, we
have a non-empty list. Why? Because if `h = 0`, then the list has no head.
And if the list has no head, then it is the empty list.

Thus, we have two cases:

1. `h == 0`
2. `h != 0`

Now, if the list is emptyâ€”`h == 0`â€”then we should have `h` and `t` point to
the new node:

```nasm
fn append(int x) -> void
	Node* n = newNode(data: x, next: 0)
	if (n == 0):
		h = t = n
```

If the list is non-emptyâ€”`h != 0`â€”then the tailend, `t`'s pointee, should
point to `n`, and `t` change its pointee to `n`:

```nasm
fn append(int x) -> void
	Node* n = newNode(data: x, next: 0)
	if (n == 0):
		h = t = n
	else:
		t->next = n;
		t = n;
```

In C++:

```cpp
#include <iostream>

void List::append(int data) {
	Node* newNode = new Node(data);
	if (head == NULL) {
		head = newNode;
		return;
	}
	Node* temp = head;
	while (temp->next != NULL) {
		temp = temp->next;
	}
	temp->next = newNode;
}
```

In JavaScript:

```javascript
append(data) {
	const newNode = new Node(data);
	if (!this.#head) {
		this.#head = newNode;
		this.#tail = this.#head;
	} else {
		this.#tail.next = newNode;
		this.#tail = newNode;
	}
	this.#length++;
	return this;
}
```

## Prepend

Say we had the following linked list:

<LinkedList data={["root", 8, 3, 9]} />

In pseudocode:

```nasm
linkedList([8, 3, 9]);
```

To prepend a new node, we want to insert the new node at the beginning of
the list. To do so, we first create a new node:

```nasm
linkedList([8, 3, 9]);
Node* n = newNode(data: 7, next: 0);
```

Second, we have `n`'s next field point to the first node in the list:

```nasm
linkedList([8, 3, 9])
Node* n = newNode(data: 7, next: 0)
n->next = firstNode
```

Finally, we make the first node the new node `n`:

```nasm
linkedList([8, 3, 9]);
Node* n = newNode(data: 7, next: 0);
n->next = firstNode;
firstNode = n;
```

The end result:

<LinkedList data={["root", 7, 8, 3, 9]} />

Examining this procedure, we see that each of these steps is a basic
stepâ€”they each take constant time. And because each step takes constant
time, prepending a new node has time complexity of ${O(1)}$â€”constant time.

```nasm
list->prepend():
	Node ð‘› := new Node(data)
	if (list->head != null):
		list->head := ð‘›
		list->tail := list->head
	else:
		ð‘›->next := list->head
		list->head := ð‘›
	list->length++
	return list
```

In C:

```cpp
#include <iostream>

Node* prepend(Node* p, int data) {
	Node* n       = newNode(data);
				n->next = p;
	return n;
}
```

In JavaScript:

```javascript
prepend(data) {
	const newNode = new Node(data);
	if (!this.#head) {
		this.#head = newNode;
		this.#tail = this.#head;
	} else {
		newNode.next = this.#head;
		this.#head = newNode;
	}
	this.#length++;
	return this;
}
```

## Get

Suppose we have the following linked list:

<LinkedList data={["root", 4, 9, 5, 3]} />

We want a function such that writing:

```nasm
list->get(3)
```

This will return the data stored at the node in position ${3.}$ In this
case, the integer `5`. Using the linked list above:

```nasm
list->get(1) ==> 4
list->get(2) ==> 9
list->get(3) ==> 5
list->get(4) ==> 3
```

In general, `get()` has the following template:

get(ð‘)

where ð‘ is a positive integer position in the list.

```nasm
list->get(uint index) => TYPE element:
	let position := index - 1
	if (position < 0) âˆ¨ (position > list->length):
		return null
	else:
		let i := 0
		let p := list->head
		while (i != position):
			p := p->next
			i++
		return p->data
```

In JavaScript:

```javascript
get(index) {
	let position = index - 1;
	if (position < 0 || position >= this.#length) {
		return null;
	} else {
		let i = 0;
		let p = this.#head;
		while (i !== position) {
			p = p.next;
			i++;
		}
		return p.data;
	}
}
```

## Set

Suppose we have the following linked list:

<LinkedList data={["root", 7, 8, 3, 9]} />

We want to a function that allows us to write:

```nasm
list->set(5, 2)
```

and results in:

<LinkedList data={["root", 7, 5, 3, 9]} />

Implementing this function follows the same pattern as `get()`.

```nasm
list->set(uint index, TYPE element) -> List:
	let position := index - 1
	if (position < 0) âˆ¨ (position > list->length):
		return null;
	else:
		let i := 0
		let p := list->head
		while (i != position):
			p := p->next
			i++
		p->data := element
		return list
```

In JavaScript:

```javascript
set(element, index) {
	let position = index - 1;
	if (position < 0 || position > this.#length) {
		return this;
	} else {
		let i = 0;
		let p = this.#head;
		while (i !== position) {
			p = p.next;
			i++;
		}
		p.data = element;
		return this;
	}
}
```

## Insert

Suppose we have the following linked list:

<LinkedList data={[7, 8, 3, 9]} />

We want to write the function:

```nasm
list->insert(5, 2)
```

such that we obtain the result:

<LinkedList data={[7, 5, 8, 3, 9]} />

To implement this function, we need two pointers: A pointer to the element
immediately before the insertion position, and a pointer to the element
immediately after. Using the previous call, we have a pointer `d` for the
position we want to insert at, and a pointer `t` for the position
immediately before:

<LinkedList
	data={[
		{ val: "root" },
		{ val: 7, ant: "t" },
		{ val: 5 },
		{ val: 8, ant: "d" },
		{ val: 3 },
		{ val: 9 },
	]}
/>

In code, suppose the insertion position is represented by the variable `i`,
and the new node is named `n`:

```nasm
linkedList(7, 8, 3, 9)
Node* n := new Node(5)
Node* t := pointer @ Node[i]
Node* d := pointer @ Node[i+1]
```

Once we have these two pointers, `n`'s next field should point to `d`, and
`t`'s pointer should point to `n`:

```nasm
linkedList(7, 8, 3, 9)
Node* n = new Node(5)
Node* t = pointer @ Node[i]
Node* d = pointer @ Node[i+1]
n->next = d
t->next = n
```

Note that `n`'s pointer must first point to `d` before we assign `t`'s
pointer to `n`. If we assigned `t`'s pointer to `n` before assigning `d`'s
pointer to `n`, we would lose `d`'s address.

In our pseudocode, we wrote `pointer @ Node[i]` and `pointer @ Node[i+1]`.
Let's flesh these expressions out. How do we get two pointers to point on
these particular nodes? After all, we don't have indices. Once again,
because we do not have indices with linked lists, we must traverse the
linked list. In our function, we will pass a particular argument, `i`, as
an abstraction for some index. This is what we use to keep track of how
many times a particular pointer will move.

In the code illustration below, notice that we don't actually need two
pointers, since the new node we create has a `next` pointer we can use:

```nasm
fn Node* insert(Node* listPtr, int data, int position):
	Node* p = listPtr;
	Node* n = newNode(data: data, next: 0);
	for (int i = 0; i < position-1; i++):
		p = p->next;
	n->next = p->next;
	p->next = n;
	return n;
```

In C++:

```cpp
#include <iostream>

Node* insert(Node* root, int data, int position) {
	Node* p = root;
	Node* n = newNode(data);
	for (int i = 0; i < position-1; i++) {
		p = p->next;
	}
	n->next = p->next;
	p->next = n;
	return root;
}
```

We could write a more generalized function, `insert()`, which can insert at
any given position in the linked list:

```cpp
	Node* insert(Node* p, int data, int position) {
		Node* m = p;
		Node* n = newNode(data);
		if (position == 0) {
			n->next = m;
			return n;
		}
		else {
			for (int i = 0; i < position - 1; i++) {
				m = m->next;
			}
			n->next = m->next;
			m->next = n;
			return p;
		}
	}
```

Testing:

```cpp
#include <iostream>

struct Node {
	int data;
	Node* next;
};

void print(Node* n) {
	std:: cout << "( ";
	while (n != 0) {
		std:: cout << n->data << " ";
		n = n->next;
	}
	std:: cout << ")\n";
}

Node* newNode(int data) {
	Node* node       = new Node;
				node->data = data;
				node->next = 0;
	return node;
}

Node* insert(Node* p, int data, int position) {
	Node* m = p;
	Node* n = newNode(data);
	if (position == 0) {
		n->next = m;
		return n;
	}
	else {
		for (int i = 0; i < position - 1; i++) {
			m = m->next;
		}
		n->next = m->next;
		m->next = n;
		return p;
	}
}

int main() {
	Node* list     = 0;
	Node* n1       = newNode(3);
				list     = n1;
	Node* n2       = newNode(2);
				n1->next = n2;
	Node* n3       = newNode(7);
				n2->next = n3;
	Node* n4       = newNode(5);
				n3->next = n4;

	print(list);

	Node* list2 = insert(list, 9, 0);

	print(list2);

	Node* list3 = insert(list2, 1, 4);

	print(list3);

	Node* list4 = insert(list3, 8, 3);

	print(list4);

	return 0;
}
```

```bash
( 3 2 7 5 )
( 9 3 2 7 5 )
( 9 3 2 7 1 5 )
( 9 3 2 8 7 1 5 )
```

Let's go over the procedure carefully. First, we pass as an argument the
pointer `listPtr`. This pointer points to the list we want to insert into.
Next, we passed `int data`. This is what will be used to initialize the new
node's data field. Then, we passed as an argument `int position`. We use
this argument to indicate where in the list we want to insert the new node.
Recall that if we pass the argument `3`, the new node is inserted after the
existing node at position three.

Inside the body, we create a new node, `n`. This node has its data field
initialized with the argument `int data`, and a `next` field of `0` (it
points nowhere at initialization).

After initializing the new node, we then iterate. Notice the loop's head.
We start at `int i = 0`, and we continue iterating so long as `i` is less
than `position - 1`. Thus, if we passed as an argument `position = 3`, the
loop executes: ${\lang 0, 1, 2 \rang}$â€”three times. At each iteration, we
move the pointer `p` forward.

For example, say we're inserting into the following linked list, where
`position = 3`.

<LinkedList data={["root", 7, 8, 3, 9]} />

Initially, the pointer `p` points to the head of the list:

<LinkedList data={["root", { val: 7, ant: "p" }, 8, 3, 9]} />

Then, we enter the for-loop. We start with `int i = 0`. The condition is
then checked: Is `i < position - 1`? Yes, ${0 < 2.}$ So, we move the
pointer `p` to the next node:

<LinkedList data={["root", 7, { val: 8, ant: "p" }, 3, 9]} />

We increment our variable `i`. Now we have `i = 1.` We check the condition
again. Is `i < position - 1`? Yes, ${0 < 1.}$ So we move the pointer `p`
once more:

<LinkedList data={["root", 7, 8, { val: 3, ant: "p" }, 9]} />

Once more we increment `i`. Now `i = 2`. The condition is checked. Is
`i < 2`? NO. ${2 \nless 2.}$ So we stop, leaving position `p` right where
we want it. While `p` was busy traversing, our new node `n` sat waiting.
Now it's time for it to spring into action. We wrote:

```nasm
n->next = p->next
```

In doing so, we now have `n` pointing to the node immediately after `p`.
This means there are now two pointers to the node immediately after `p`.
`p->next`, and `n->next`. Now `p` comes back into play. We wrote:

```nasm
p->next = n;
```

In doing so, `p->next` now points to `n`, the new node. This completes the
linking. `p->next` points `n`, and `n` points to the node that was
previously `p->next`'s pointee. We've successfully inserted the node.

### Sorted Insertions

Suppose we had the following linked list:

<LinkedList data={["root", 3, 7, 9, 15, 20]} />

Notice that the elements in this list are sorted. Say we wanted to insert a
node with the data `18`. When we insert into a sorted list, we usually want
to maintain the list's sorted nature. We call this a _sorted insertion_. In
this case, we want ${n(18)}$ to come after ${n(15)}$ and before ${n(20).}$
If we want to insert ${n(10),}$ it should come after ${n(9)}$ and before
${n(5).}$

Implementing this procedure is fairly straightforward. Consider inserting
the node ${n(18).}$ We go to the first node, ${n(3),}$ and ask, is
${n(3) < n(18)?}$

<LinkedList data={["root", { val: 3, ant: "p" }, 7, 9, 15, 20]} />

True. So we move to the next node and ask, is ${n(7) < n(18)?}$:

<LinkedList data={["root", 3, { val: 7, ant: "p" }, 9, 15, 20]} />

Again, true. So we move to the next node:

<LinkedList data={["root", 3, 7, { val: 9, ant: "p" }, 15, 20]} />

Once more, true. So we move the next node:

<LinkedList data={["root", 3, 7, 9, { val: 15, ant: "p" }, 20]} />

True. Move to the next node:

<LinkedList data={["root", 3, 7, 9, 15, { val: 20, ant: "p" }]} />

Finally, we get false. And since we get false, we want to insert ${n(18)}$
after ${n(15)}$ and before ${n(20).}$ Now, recall that to insert a new node
into a linked list, we need two pointersâ€”the _driver_, denoted `d`, and the
_tailer_, denoted `t`. And given that we have need two pointers, we have to
move the pointers' pointees around in our iteration.

Initially, the pointer `d` has been initialized and points nowhere
(`t = NULL`). At the first iteration, we see that `n(3) < n(18)` is true.

<LinkedList data={["root", 3, 7, 9, 15, 20]} />

The next iteration, we see that `n(7) < n(18)` is true. So, the pointer `d`
moves to the second node, and the pointer `t` moves to the first node.

<LinkedList data={["root", { val: 3, ant: "d" }, 7, 9, 15, 20]} />

Next iteration: `n(9) < n(18)` is true. The pointer `d` moves to the third
node, and the pointer `t` moves to the second node.

<LinkedList
	data={["root", { val: 3, ant: "t" }, { val: 7, ant: "d" }, 9, 15, 20]}
/>

Fourth iteration: `n(15) < n(18)` is true. The pointer `d` moves to the
fourth node, and the pointer `t` moves to the third node.

<LinkedList
	data={["root", 3, { val: 7, ant: "t" }, { val: 9, ant: "d" }, 15, 20]}
/>

Fifth iteration: `n(20) < n(18)` is false. The pointer `d` moves to the
fifth node, and the pointer `t` moves to the fourth node.

<LinkedList
	data={["root", 3, 7, { val: 9, ant: "t" }, { val: 15, ant: "d" }, 20]}
/>

Notice that once we get `d` and `t` place, to insert the new node
${n(18),}$ all we must do is have ${n(18)}$ point to `p` and `t`'s pointee
point to ${n(18).}$ The function generally:

<LinkedList
	data={["root", 3, 7, 9, { val: 15, ant: "t" }, { val: 20, ant: "d" }]}
/>

```nasm
fn sortedInsert(Node* p, int dVal):
	Node* n = newNode(data: dVal, next: NULL);
	Node* d = p;
	Node* t = NULL;
	while (d && (d->data < dVal)):
		t = d;
		d = d->next;
	n->next = t->next;
	t->next = n;
	return p;
```

With this approach, the time it takes to link the nodes is constant
â€”${O(1).}$ But, the time it takes for the driver and the tailer to reach
their respective positions is ${O(n)}$â€”linear. This is because both `d` and
`t` must traverse the list to reach their correct destinations.

Here's an implementation in C:

```c
#include <stdio.h>
#include <stdlib.h>

struct Node {
	int data;
	struct Node* next;
};

struct Node* newNode(int data) {
	struct Node* node = (struct Node*) malloc(sizeof(struct Node*));
	(*node).data = data;
	(*node).next = NULL;
	return node;
}

struct Node* arrayToList(int arr[], int size) {
	struct Node* head = newNode(arr[0]);
	struct Node* tailend = head;
	for (int i = 1; i < size; i++) {
		struct Node* freshNode = newNode(arr[i]);
		(*tailend).next = freshNode;
		tailend = freshNode;
	}
	return head;
}

void print(struct Node* p) {
	printf("( ");
	if (p == NULL) {
		printf("empty");
	};
	while (p != NULL) {
		printf("%d ", (*p).data);
		p = (*p).next;
	}
	printf(")\n");
}

void sortedInsert(struct Node* p, int dataVal) {
	struct Node* head = p;
	struct Node* freshNode = newNode(dataVal);
	struct Node* tailer;
	if (p == NULL) {
		head = freshNode;
	} else {
		while (head && (*head).data < dataVal) {
			tailer = head;
			head = (*head).next;
		}
		if (head == p) {
			(*freshNode).next = head;
			head = freshNode;
		} else {
			(*freshNode).next = (*tailer).next;
			(*tailer).next = freshNode;
		}
	}
}

int main() {
	int arr[] = {3, 5, 8, 9};
	struct Node* list = arrayToList(arr, 4);
	print(list);
	sortedInsert(list, 7);
	print(list);
	return 0;
}
```

```bash
(3 5 8 9)
(3 5 7 8 9)
```

Here is an implementation of what we have so far as a class in C++:

```cpp
#include <iostream>

struct Node {
	int data;
	Node* next;
	Node(int data) {
		this->data = data;
		this->next = NULL;
	}
};

class List {
	Node* head;
	Node* foot;
	int length;

	public:
		List(int data) {
			this->head = new Node(data);
			this->foot = head;
			this->length = 1;
		}
		List(int arr[], int size) {
			this->head = new Node(arr[0]);
			this->foot = head;
			for (int i = 1; i < size; i++) {
				Node* newNode = new Node(arr[i]);
				this->foot->next = newNode;
				this->foot = newNode;
			}
			this->length = size;
		}
		void append(int data) {
			Node* newNode = new Node(data);
			if (this->head == NULL) {
				this->head->next = newNode;
				this->length = 1;
			} else {
				this->foot->next = newNode;
				this->foot = newNode;
				this->length++;
			}
		}
		void prepend(int data) {
			Node* newNode = new Node(data);
			if (this->head == NULL) {
				this->head = newNode;
				this->length = 1;
			} else {
				newNode->next = this->head;
				this->head = newNode;
				this->length++;
			}
		}
		void insert(int data, int position) {
			Node* newNode = new Node(data);
			if (position == 0) {
				prepend(data);
			} else {
				Node* p = this->head;
				for (int i = 0; i < position - 1; i++) {
					p = p->next;
				}
				newNode->next = p->next;
				p->next = newNode;
				this->foot = newNode;
				this->length++;
			}
		}
		void print() {
			Node* ptr = this->head;
			std::cout << "( ";
			while (ptr != NULL) {
				std::cout << ptr->data << " ";
				ptr = ptr->next;
			}
			std::cout << ")\n";
		}
		int getLength() {
			return this->length;
		}
};
```

## List Reversal

Suppose we have the following linked list:

<LinkedList data={["root", 8, 7, 3, 5]} />

When we perform a __list reversal__, we end up with the following list:

<LinkedList data={["root", 5, 3, 7, 8]} />

As we can see, list reversals are useful for quickly reorienting data. If
we have a list with elements ascendingly sorted, reversing yields a list
with elements descendingly sorted, and vice versa.

There are two ways to reverse a linked list:

1. _list reversal by element_, or
2. _list reversal by link_.

### Reverse-by-element

Let's consider the first approach, reversing by element, using the
following list to illustrate:

<LinkedList data={["root", 3, 6, 8, 9]} />

To reverse by element, we start by focusing on the head and the foot:

<LinkedList
	data={["root", { val: 3, ant: "head" }, 6, 8, { val: 9, ant: "foot" }]}
/>

Then, we swap the values stored in the two nodes's data fields:

<LinkedList
	data={["root", { val: 9, ant: "head" }, 6, 8, { val: 3, ant: "foot" }]}
/>

After doing so, we move to the next nodes:

<LinkedList
	data={["root", 9, { val: 6, ant: "head" }, { val: 8, ant: "foot" }, 3]}
/>

Once more we swap the values stored in the two nodes's data fields:

<LinkedList
	data={["root", 9, { val: 8, ant: "head" }, { val: 6, ant: "foot" }, 3]}
/>

This yields our desired result:

<LinkedList data={["root", 9, 8, 6, 3]} />

To implement this procedure, we need a way to store the data values we're
swapping. The most straightforward way is to use an array: We traverse the
linked list, and initialize the array's elements with the current node's
data value. Using the previous list (call it `list0`), we first declare an
array whose size equals the number of nodes in the list:

```nasm
	List list0 = new List(3, 6, 8, 9)
	let uint size = List->length
	let array[size] = []
	int arr[size]
```

<LinkedList data={["root", 3, 6, 8, 9]} />
<Sequence data={["", "", "", ""]} />

Next, we have a pointer `p` point to the head of the list, and assign the
data value stored in the head to the first index in the array:

```nasm
	List list0 = new List(3, 6, 8, 9)
	let uint size = List->length
	let array[size] = []
	Node* p = list0->head
	p->data = array[0]
```

<LinkedList data={["root", { val: 3, ant: "p" }, 6, 8, 9]} />
<Sequence data={[3, "", "", ""]} />

To completely fill the array, we iterate:

```nasm
	List list0 = new List(3, 6, 8, 9)
	let uint size = List->length
	let array[size] = []
	Node* p = list0->head
	p->data = array[0]
	let i = 0
	while (p isnt null):
		array[i] = p->data
		p = p->next
		i++
```

After the while loop finishes, we have all of the elements in the array:

<LinkedList data={["root", 3, 6, 8, 9]} />

<Sequence data={[3, 6, 8, 9]} />

Once we've finished initializing all of the array's elements, we bring `p`
back to the first node:

```nasm
	List list0 = new List(3, 6, 8, 9)
	let uint size = List->length
	let array[size] = []
	Node* p = list0->head
	p->data = array[0]
	let i = 0
	while (p isnt null):
		array[i] = p->data
		p = p->next
		i++
	p = list->head
```

<LinkedList data={["root", { val: 3, ant: "p" }, 6, 8, 9]} />

<Sequence data={[3, 6, 8, 9]} />

Then, we want to decrement `i` and use another while-loop to assign the
contents in the auxiliary array to the list. Since our while loop ended at
`i = 4`, this results in assigning to `p`'s pointee's `data` field
`array[3]`, `array[2]`, `array[1]`, and so on:

```nasm
	List list0 = new List(3, 6, 8, 9)
	let uint size = List->length
	let array[size] = []
	Node* p = list0->head
	p->data = array[0]
	let i = 0
	while (p isnt null):
		array[i] = p->data
		p = p->next
		i++
	p = list->head
	i--
	while (p isnt null):
		p->data = A[i]
		i--
		p = p->next
```

The end result:

<LinkedList data={["root", 9, 8, 6, 3]} />
<Sequence data={[3, 6, 8, 9]} />

We have several costs with this approach. First, we need additional memory
for the auxiliary array, equal to the number nodes ${n}$ in the linked
list. Accordingly, the procedure above has a space complexity of ${O(n).}$
And in terms of time, we must traverse the linked list twice, yielding a
running time function of roughly ${T(2n).}$ Asymptotically, this yields a
time complexity of ${O(n).}$

### Reverse-by-link

Next, let's consider reversing by link. Say we had the following list:

<LinkedList data={["root", 9, 8, 6, 3]} />

With this approach, we just switch the direction of each node's next
pointer. ${n(3)}$'s next pointer points to ${n(6)}$ (rather than `NULL`),
${n(6)}$'s next pointer points to ${n(8)}$ (rather than ${n(3)}$), and
${n(8)'s}$ pointer points ${n(9)}$ (rather than ${n(6).}$)

Two reverse a list by link, we must use the technique of **pointer
sliding**. The idea is as such: We start with four pointers. One pointing
at the head called `h`, and three other pointers, `d`, `t1`, and `t2`. The
driver pointer `d` initially points to the head, while `t1` and `t2` are
initially `NULL`:

<LinkedList data={["root", { val: 9, ant: "h d" }, 8, 6, 3]} />

Then, as long as `d != NULL`, we want to _slide_ the pointers forward: `t2`
points to `t1`'s pointee, `t1` points to `d`'s pointee, and `d` points to
its `next` address. And each time we slide, `t1`'s `next` pointer should
point to `t2`.

The best way to illustrate pointer sliding is with a trace table.
Initially, we have:

| `h`    | `t1`   | `t1->next` | `t2`   | `d`    | `d->next` |
| ------ | ------ | ---------- | ------ | ------ | --------- |
| `n(9)` | `null` | `null`     | `null` | `n(9)` | `n(8)`    |

Because `d` is not null, we slide. `t2`'s pointee now becomes `t1`'s
pointee, `t1`'s pointee changes to `d`'s pointee, and `t1`'s pointee's
`next` pointer should point to `t2`'s pointee.

| `h`    | `t1`   | `t1->next` | `t2`   | `d`    | `d->next` |
| ------ | ------ | ---------- | ------ | ------ | --------- |
| `n(9)` | `null` | `null`     | `null` | `n(9)` | `n(8)`    |
| `n(9)` | `n(9)` | `null`     | `null` | `n(8)` | `n(6)`    |

`d` is still not null, so we slide again. `t2`'s pointee becomes `t1`'s
pointee, `t1`'s pointee changes to `d`'s pointee, and `t1`'s pointee's
`next` pointer should point to `t2`'s pointee.

| `h`    | `t1`   | `t1->next` | `t2`   | `d`    | `d->next` |
| ------ | ------ | ---------- | ------ | ------ | --------- |
| `n(9)` | `null` | `null`     | `null` | `n(9)` | `n(8)`    |
| `n(9)` | `n(9)` | `null`     | `null` | `n(8)` | `n(6)`    |
| `n(9)` | `n(8)` | `n(9)`     | `n(9)` | `n(6)` | `n(3)`    |

Again `d` is not null, we so slide:

| `h`    | `t1`   | `t1->next` | `t2`   | `d`    | `d->next` |
| ------ | ------ | ---------- | ------ | ------ | --------- |
| `n(9)` | `null` | `null`     | `null` | `n(9)` | `n(8)`    |
| `n(9)` | `n(9)` | `null`     | `null` | `n(8)` | `n(6)`    |
| `n(9)` | `n(8)` | `n(9)`     | `n(9)` | `n(6)` | `n(3)`    |
| `n(9)` | `n(6)` | `n(8)`     | `n(8)` | `n(3)` | `null`    |

`d` is still not `null`, so we slide once more:

| `h`    | `t1`   | `t1->next` | `t2`   | `d`    | `d->next` |
| ------ | ------ | ---------- | ------ | ------ | --------- |
| `n(9)` | `null` | `null`     | `null` | `n(9)` | `n(8)`    |
| `n(9)` | `n(9)` | `null`     | `null` | `n(8)` | `n(6)`    |
| `n(9)` | `n(8)` | `n(9)`     | `n(9)` | `n(6)` | `n(3)`    |
| `n(9)` | `n(6)` | `n(8)`     | `n(8)` | `n(3)` | `null`    |
| `n(9)` | `n(3)` | `n(6)`     | `n(6)` | `null` | `--`      |

Now we have `d` is null. All that's left to do is set the `h` pointer (it's
always been pointing at the head), to `t1`:

| `h`    | `t1`   | `t1->next` | `t2`   | `d`    | `d->next` |
| ------ | ------ | ---------- | ------ | ------ | --------- |
| `n(9)` | `null` | `null`     | `null` | `n(9)` | `n(8)`    |
| `n(9)` | `n(9)` | `null`     | `null` | `n(8)` | `n(6)`    |
| `n(9)` | `n(8)` | `n(9)`     | `n(9)` | `n(6)` | `n(3)`    |
| `n(9)` | `n(6)` | `n(8)`     | `n(8)` | `n(3)` | `null`    |
| `n(9)` | `n(3)` | `n(6)`     | `n(6)` | `null` | `--`      |
| `t1`   | `n(3)` | `n(6)`     | `n(6)` | `null` | `--`      |

Notice how we've essentially reversed the list. Reading from left to right,
starting from the bottom, we see:

```nasm
(t1   n(3)   n(6)   n(8)   n(9)   null)
```

In pseudocode:

```nasm
list->reverse() => list:
	d  = list->head
	t1 = null
	t2 = null
	while (d isnt null):
		t2       = t1
		t1       = d
		d        = d->next
		t1->next = 2
	head = t1
	return list
```

As we can see, reversing links is the preferred approach for list reversal.
Why? Because reversing-by-link consumes far less memory. We just need three
more pointers. Compare that with reverse-by-element, which requires an
entire array. With our examples, we've been using `int`. But the data field
for each node in the linked list could very well contain arrays, or even
larger data structures. This would lead to an even larger memory
consumption.

Although both approaches take ${O(n)}$ timeâ€”since we must traverse the
linked listâ€”reverse-by-link consumes much less memory. In fact, whenever
we're called to move nodes in a linked list, our first consideration should
always be to manipulate links, rather than data fields.

Here's an implementation in JavaScript:

```javascript
reverse() {
	let tempNode = this.#head;
	this.#head = this.#tail;
	this.#tail = tempNode;
	let nextNode;
	let previous = null;
	for (let i = 0; i < this.#length; i++) {
		nextNode = tempNode.next;
		tempNode.next = previous;
		previous = tempNode;
		tempNode = nextNode;
	}
	return this;
}
```

### Recursive List Reversal

With recursive list reversal, we want to reverse the link of each node as
we're returning from the function call:

```nasm
reverse(Node** head) => void:
	reverseLink(Node* q, Node* p) => void:
		if (p isnt null):
			reverseLink(p, p->next)
			p->next = q
		else:
			*head = q
	reverseLink(NULL, *head)
```

The function's call would be written as:

```nasm
	reverse(&list)
```

To understand how this function works, it's helpful to trace the
operations. Suppose we called it on this list:

<LinkedList data={["root", 1, 2, 3]} />

Calling `reverse()` results in the following:

```nasm
**head = &list
```

visually:

<LinkedList data={[{ val: "root", ant: "head" }, 1, 2, 3]} />

Inside `reverse()`, we call `reverseLink()`. This results in `q` pointing
to nowhere and `p` pointing to the the pointer `head` points to.

```nasm
reverse:
	**head = &list
	reverseLink:
		Node* q = null
		Node* p = null
```

<LinkedList data={[{ val: "root", ant: "head p" }, 1, 2, 3]} />

Once these pointers are initialized, we branch. If `p != NULL`, we execute
the if-block. Otherwise, we execute the else-block. Here, `p` is a nonnull
pointer, so we make the recursive call `reverseLink(p, p->next)`.

```nasm
reverse:
	**head = &list
	reverseLink:
		Node* q = null
		Node* p = null
		reverseLink:
			Node* q = p         // q is null
			Node* p = p->next   // p is now n(1)
```

<LinkedList
	data={[{ val: "root", ant: "head q" }, { val: 1, ant: "p" }, 2, 3]}
/>

We again check our test condition. Once more, `p != NULL`, so we make
another recursive call:

```nasm
reverse:
	**head = &list
	reverseLink:
		Node* q = null
		Node* p = null
		reverseLink:
			Node* q = p             // q is null
			Node* p = p->next       // p is now n(1)
			reverseLink:
				Node* q = p           // q is now n(1)
				Node* p = p->next     // p is now n(2)
```

<LinkedList
	data={[
		{ val: "root", ant: "head" },
		{ val: 1, ant: "q" },
		{ val: 1, ant: "p" },
		3,
	]}
/>

We again check our test condition, and find that `p` is the nonnull
pointer, so we make another recursive call:

```nasm
reverse:
	**head = &list
	reverseLink:
		Node* q = null
		Node* p = null
		reverseLink:
			Node* q = p                     // q is null
			Node* p = p->next               // p is now n(1)
			reverseLink:
				Node* q = p                 // q is n(1)
				Node* p = p->next           // p is now n(2)
				reverseLink:
					Node* q = p             // q is now n(2)
					Node* p = p->next       // p is now n(3)
```

<LinkedList
	data={[
		{ val: "root", ant: "head" },
		1,
		{ val: 2, ant: "q" },
		{ val: 3, ant: "p" },
	]}
/>

Once more we test whether `p != NULL`. Again, it is not. So we make one
last recursive call:

```nasm
reverse:
	**head = &list
	reverseLink:
		Node* q = null
		Node* p = null
		reverseLink:
			Node* q = p               // q is null
			Node* p = p->next         // p is now n(1)
			reverseLink:
				Node* q = p             // q is n(1)
				Node* p = p->next       // p is now n(2)
				reverseLink:
					Node* q = p           // q is now n(2)
					Node* p = p->next     // p is now n(3)
					reverseLink:
						Node* q = p         // q is now n(3)
						Node* p = p->next   // p is now null
```

<LinkedList
	data={[{ val: "root", ant: "head" }, 1, 2, { val: 3, ant: "q" }]}
/>

With this last call, `p` is now the null pointer, so we execute the line
`p->next = q`.

```nasm
reverse:
	**head = &list
	reverseLink:
		Node* q = null
		Node* p = null
		reverseLink:
			Node* q = p                     // q is null
			Node* p = p->next               // p is now n(1)
			reverseLink:
				Node* q = p                   // q is n(1)
				Node* p = p->next             // p is now n(2)
				reverseLink:
					Node* q = p                 // q is now n(2)
					Node* p = p->next           // p is now n(3)
					reverseLink:
						Node* q = p               // q is now n(3)
						Node* p = p->next         // p is now null
					p->next = q                 // n(3)->next = n(2)
				p->next = q                   // n(2)->next = n(1)
			p->next = q                     // n(1)->next = null
```

With the last return call, we have `p == NULL`, so we execute the else
block: `*head = q`.

```nasm
reverse:
	**head = &list
	reverseLink:
		Node* q = null
		Node* p = null
		reverseLink:
			Node* q = p
			Node* p = p->next
			reverseLink:
				Node* q = p
				Node* p = p->next
				reverseLink:
					Node* q = p
					Node* p = p->next
					reverseLink:
						Node* q = p
						Node* p = p->next
						p->next = q => n(3)
					n(3)->next = n(2)
				n(2)->next = n(1)
			n(1)->next = null
		*head = n(1)
```

In pseudocode:

```nasm
reverse(Node** head) => void:
	reverseLink(Node* q, Node* p) => void:
		if (p isnt null):
			reverseLink(p, p->next)
			p->next = q
		else:
			*head = q
	reverseLink(NULL, *head)
```

Below is an implementation in C. Note that because C does not allow nested
functions, the helper function `reverseLink()` must be written separately:

```c
void reverseLink(struct Node **head, struct Node *q, struct Node *p) {
	if (p != NULL) {
		reverseLink(head, p, (*p).next);
		(*p).next = q;
	} else {
		*head = q;
	}
}

void reverse(struct Node **head) {
	reverseLink(head, NULL, *head);
}
```

Testing:

```c
#include <stdlib.h>
#include <stdio.h>

struct Node {
	int data;
	struct Node *next;
};

struct Node *newNode(int newData) {
	struct       Node *freshNode = malloc(sizeof(struct Node));
	(*freshNode).data            = newData;
	(*freshNode).next            = NULL;
	return freshNode;
}

struct Node *list(int arr[], int size) {
	struct Node *head = newNode(arr[0]);
	struct Node *foot = head;
	for (int i = 1; i < size; i++) {
		struct  Node *freshNode = newNode(arr[i]);
		(*foot).next            = freshNode;
						foot            = freshNode;
	}
	return head;
}

void print(struct Node *headPtr) {
	printf("(  ");
	if (headPtr == NULL) {
		printf("empty \n");
	} else {
		while (headPtr != NULL) {
			printf("%'d  ", (*headPtr).data);
			headPtr = (*headPtr).next;
		}
	}
	printf(")\n");
}

void reverseLink(struct Node **head, struct Node *q, struct Node *p) {
	if (p != NULL) {
		reverseLink(head, p, (*p).next);
		(*p).next = q;
	} else {
		*head = q;
	}
}

void reverse(struct Node **head) {
	reverseLink(head, NULL, *head);
}


int main() {
	int    size        = 5;
	int    arr[]       = {1,2,3,4,5};
	struct Node* aList = list(arr, size);
	print(aList);
	reverse(&aList);
	print(aList);
	return 0;
}
```

```bash
(  1  2  3  4  5  )
(  5  4  3  2  1  )
```

## Sum of All Elements

Just as we saw with arrays, given a linked list of numeric type, we can
find the sum of all its elements through iteration. Suppose we had the
following linked list:

<LinkedList data={["root", 7, 3, 5, 4]} />

In code:

```cpp
#include <iostream>

struct Node {
	int data;
	Node* next;
};

Node* newNode(int data) {
	Node* node       = new Node;
				node->data = data;
				node->next = 0;
	return node;
}

int main() {
	Node* root        = 0;
	Node* node1       = newNode(7);  // First node
				root        = node1;
	Node* node2       = newNode(3);  // Second node
				node1->next = node2;
	Node* node3       = newNode(5)   // Third node
				node2->next = node3;
	Node* node4       = newNode(4)   // Fourth node
				node3->next = node4;

	return 0;
}
```

To sum all of the elements, we use a variable `sum`, set initially to zero.
Then, we iterate through the linked list, incrementing `sum` by each
element's `data` field:

```cpp
int listSum(Node* p) {
	int sum = 0;
	while (p != 0) {
		sum += p->data;
		p    = p->next;
	}
	return sum;
}
```

Testing:

```cpp
#include <iostream>

struct Node {
	int data;
	Node* next;
};

Node* newNode(int data) {
	Node* node       = new Node;
				node->data = data;
				node->next = 0;
	return node;
}

int listSum(Node* p) {
	int sum = 0;
	while (p != 0) {
		sum += p->data;
		p    = p->next;
	}
	return sum;
}

int main() {
	Node* root        = 0;
	Node* node1       = newNode(7);  // First node
				root        = node1;
	Node* node2       = newNode(3);  // Second node
				node1->next = node2;
	Node* node3       = newNode(5);  // Third node
				node2->next = node3;
	Node* node4       = newNode(4);  // Fourth node
				node3->next = node4;

	Node* sumPtr = root;
	int   sum    = listSum(sumPtr);

	std::cout << sum << std::endl;

	return 0;
}
```

```bash
19
```

The time complexity for this function is linear, and the space complexity
is constant. We're iterating through ${n}$ nodes, and the operations of
`==` and `+=` are basic steps. Accordingly, the function has a time
complexity of ${O(n).}$ With respect to space, only a single function call
is made, and each of the variables take a fixed amount of memory. Hence,
the space complexity is ${O(1).}$

### Recursive Approach.

The same function can be implemented recursively:

```cpp
int listSum(Node* p) {
	if (p == 0) {
		return 0;
	} else {
		return listSum(p->next) + p->data;
	}
}
```

With the recursive approach, the time complexity is ${O(n),}$ just as we
saw with the iterative approach. The space complexity, however, is
${O(n),}$ given that ${n+1}$ calls must be made.

## Peak Finder

As we saw with arrays, a __peak finder__ is an algorithm for finding the
maximum element in a given collection. In this case, the maximum element in
a linked list.

Suppose ${n_0}$ is the head, and it contains the peak, ${v_0,}$ in its data
field. Iterating through the linked list, compare ${v_0}$ against ${v_1,}$
the value in the data field of the second node, ${n_1.}$ If ${v_0 < v_1,}$
then ${n_1}$ contains the peak. Otherwise, ${v_0}$ is the peak, and we
compare it against ${v_2,}$ the value in the data field of the third node.
The process until we reach the foot of the list: If ${v_i < v_{i+1},}$ then
${v_{i+1}}$ is the maximum element. Otherwise, compare ${v_i}$ against
${v_{i+2 \ldots k}.}$

Implementing this procedure:

```cpp
int findMax(Node* p) {
	int max = p->data;
	while (p != 0) {
		if (p->data > max) {
			max = p->data;
		}
		p = p->next;
	}
	return max;
}
```

For testing, let's say we had the following linked list:

<LinkedList data={["root", 312, 219, 317, 319]} />

The diagram shows that ${319}$ is the maximum element, so we should expect
to see ${319}$ as the output. Testing:

```cpp
#include <iostream>

struct Node {
	int data;
	Node* next;
};

Node* newNode(int data) {
	Node* p       = new Node;
				p->data = data;
				p->next = 0;
	return p;
}

int findMax(Node* p) {
	int max = p->data;
	while (p != 0) {
		if (p->data > max) {
			max = p->data;
		}
		p = p->next;
	}
	return max;
}

int main() {
	Node* root        = 0;
	Node* node1       = newNode(312);
				root        = node1;
	Node* node2       = newNode(219);
				node1->next = node2;
	Node* node3       = newNode(313);
				node2->next = node3;
	Node* node4       = newNode(319);
				node3->next = node4;

	Node* temp     = root;
	int   maxValue = findMax(temp);

	std::cout << maxValue << std::endl;

	return 0;
}
```

```bash
319
```

Note that there are a variety of ways to implement the same function.
Another approach is to set the initial `max` to `INT_MIN`, the smallest
possible `int` value:

```cpp
int findMax(Node* p) {
	int max = INT_MIN;
	while (p != 0) {
		if (p->data > max) {
			max = p->data;
		}
		p = p->next;
	}
	return max;
}
```

### Recursive Implementation

The recursive peak finder is somewhat longer:

```cpp
int findMax(Node* p) {
	int x = 0;
	if (p == 0) {
		return INT_MIN;
	} else {
		x = findMax(p->next);
		if (x > p->data) {
			return x;
		} else {
			return p->data;
		}
	}
}
```

Of course, we can shorten it with the ternary operator:

```cpp
int findMax(Node* p) {
	int x = 0;
	if (p == 0) {
		return INT_MIN;
	}
	x = findMax(p->next);
	return x > p->data ? x : p->data;
}
```

## Valley Finder

In contrast to peak finding, the __valley finder__ is an algorithm for
finding the mimimum element. The implementation is similar to the peak
finder; the only difference is we're looking for the smallest element.

```cpp
int findMin(Node* p) {
	int min = p->data;
	while (p != 0) {
		if (p->data < min) {
			min = p->data;
		}
		p = p->next;
	}
	return min;
}
```

Testing:

```cpp
#include <iostream>

struct Node {
	int data;
	Node* next;
};

Node* newNode(int data) {
	Node* node       = new Node;
				node->data = data;
				node->next = 0;
	return node;
}

int findMin(Node* p) {
	int min = p->data;
	while (p != 0) {
		if (p->data < min) {
			min = p->data;
		}
		p = p->next;
	}
	return min;
}

int main() {
	Node* root        = 0;
	Node* node1       = newNode(3);
				root        = node1;
	Node* node2       = newNode(9);
				node1->next = node2;
	Node* node3       = newNode(1);
				node2->next = node3;
	Node* node4       = newNode(7);
				node3->next = node4;

	Node* list = root;

	int listMin = findMin(list);

	std::cout << listMin << std::endl;

	return 0;
}
```

```bash
1
```

## Searching a Linked List

As we saw with arrays, we can search through a linked list. The catch,
however, is that we cannot employ binary search. This is because with the
linked list, we do not have indices. There are only pointers. The only way
for us to know when we've reached some element is by traversing. And
because we have no choice but to traverse, we cannot access the middle node
in constant time. As such, binary search on a linked list is no better than
a linear search.

That said, suppose we had the following linked list:

<LinkedList data={["root", 3, 9, 5, 2, 4]} />

Now suppose our query is `2`. From the linked list above, that's the fourth
node. Searching for our query is similar to linear searching through an
arrayâ€”we just have to pass the value we want found, and a pointer to the
linked list.

```cpp
Node* linearSearch(Node* p, int query) {
	while(p != 0) {
		if (p->data == query) {
			return p;
		}
		p = p->next;
	}
	return 0;
}
```

With the implementation above, we're returning a pointer to the query if
it's found. Otherwise, we return `0`, in which case the pointer to the
query is null. This, of course, is entirely arbitrary. We could return
`true`, `false`, `1`, `0`, or print some output to the console.

Testing with the diagram above:

```cpp
#include <iostream>

struct Node {
	int data;
	Node* next;
};

Node* newNode(int data) {
	Node* node = new Node;
				node->data = data;
				node->next = 0;
	return node;
}

Node* linearSearch(Node* p, int query) {
	while(p != 0) {
		if (p->data == query) {
			return p;
		}
		p = p->next;
	}
	return 0;
}

int main() {
	Node* root        = 0;
	Node* node1       = newNode(3);
				root        = node1;
	Node* node2       = newNode(9);
				node1->next = node2;
	Node* node3       = newNode(5);
				node2->next = node3;
	Node* node4       = newNode(2);
				node3->next = node4;
	Node* node5       = newNode(4);
				node4->next = node5;
	Node* list        = root;
	Node* query       = linearSearch(list, 2);

	std::cout << query->data << std::endl;

	return 0;
}
```

```bash
2
```

As we saw with arrays, however, we can improve linear search through
_transposition_ or _move-to-head_. Recall that with transposition, whenever
we search for a particular element, the element moves closer to the
beginning. And with move-to-head, the element containing the key moves
immediately to the head after a successful search.

It turns out that transposition isn't a very good idea, but before we
address why, let's consider move-to-head, the preferred approach with
linked lists. To start, let's consider the following linked list, supposing
the key we're searching for is `7`:

<LinkedList data={["root", 8, 3, 7, 4]} />

This is the third node, and we want to make it the list's head. As we saw
with our implementation of linear search earlier, we used a temporary
pointer to traverse the linked list, so as to check for equality to our
key. Thus, conducting linear search on our linked list, the temporary
pointer, at some point, reaches the node storing `7`. As such, once we
reach the node storing `7`, we want to bring the node to the head.

To do so, we must modify the second node, since the third node will move.
In this case, the second nodeâ€”the node right before our keyâ€”should point
the third nodeâ€”the node right after our key. To do so, we must have a
pointer on the node immediately before our key as well.

<LinkedList data={["root", 8, { val: 3, ant: "p" }, 7, 4]} />

How do we get a pointer on the previous node? By using a second pointer.
Thus, our linear search will use two pointersâ€”`p`, the __traverser__, and
`q`, the __tailer__, that follows immediately behind `p`. Then, the two
pointers work together as follows:

1. `p` begins traversing, starting at the first node. If the key is there,
   stop. Return the node's address. Otherwise, proceed to the next step. In
   this case, it is not.

2. Since the first node is not the key, `p` moves to the second node _and_
   `q` points to the first node.

3. Once again, we found no match, so `p` moves to the next nodeâ€”the third
   nodeâ€”and `q` moves to the next node, the second node. At this point
   we've found our key.

Notice the end result. We have a pointer to the node just before the node
containing the key, and a pointer to the node containing the key. This is
exactly where we want to be. The implementation:

```cpp
Node* linearSearch(Node* root, int key) {
	Node* current = root;
	Node* previous = 0;
	while (current != 0) {
		if (current->data == key) {
			previous->next = current->next;
			current->next = root;
			root = current;
			return root;
		}
		previous = current;
		current = current->next;
	}
	return 0;
}
```

Testing:

```cpp
#include <iostream>

struct Node {
	int data;
	Node* next;
};

Node* newNode(int data) {
	Node* node       = new Node;
				node->data = data;
				node->next = 0;
	return node;
}

void print(Node* p) {
	while(p != 0) {
		std::cout << p->data << " --> ";
		p = p->next;
	}
	std::cout << "\n";
}

Node* linearSearch(Node* root, int key) {
	Node* current  = root;
	Node* previous = 0;
	while (current != 0) {
		if (current->data == key) {
			previous->next = current->next;
			current->next  = root;
			root           = current;
			return root;
		}
		previous = current;
		current  = current->next;
	}
	return 0;
}

int main() {
	Node* root        = 0;
	Node* node1       = newNode(3);
				root        = node1;
	Node* node2       = newNode(5);
				node1->next = node2;
	Node* node3       = newNode(7);
				node2->next = node3;
	Node* node4       = newNode(9);
				node3->next = node4;
	print(root);
	Node* key = linearSearch(root, 7);
	std::cout << key->data << std::endl;
	print(key);
	return 0;
}
```

```bash
3 --> 5 --> 7 --> 9 -->
7
7 --> 3 --> 5 --> 9 -->
```

### Recursive Implementation

We could've also implemented the linear search function recursively:

```cpp
Node* recursiveLinearSearch(Node* p, int query) {
	if (p == 0) {
		return 0;
	} else if (query == p->data) {
		return p;
	} else {
		return recursiveLinearSearch(p->next, query);
	}
}
```

## Sorted Test

Many algorithms on linked lists depend on whether a given linked list is
sorted. By sorted linked list, we mean a linked list whose data fields are
sorted according to a particular criteria. Most often, that criteria is
numeric. For example, the following linked list is sorted:

<LinkedList data={["root", 3, 5, 8, 12, 16]} />

To determine if a linked list is sorted, we use a __sorted test__. The
procedure is as follows.

First, we have a pointer to the first node, and some variable ${m,}$ set to
the smallest possible valube for the linked list's type. For example, with
`int`, the smallest possible value is `-32768`. With a pointer on the first
node, we check if ${m < n(3)?}$

<LinkedList data={["root", { val: 3, ant: "p" }, 5, 8, 12, 16]} />

Clearly yes. So, we change ${m = 3,}$ move the pointer to the next node,
and test, ${3 < n(5)?}$

<LinkedList data={["root", 3, { val: 5, ant: "p" }, 8, 12, 16]} />

Once more, yes. We mutate ${m}$ to ${m = 5,}$ and we move to the next node.
Test again: Is ${5 < n(8)?}$

<LinkedList data={["root", 3, 5, { val: 8, ant: "p" }, 12, 16]} />

Once again, yes. We modify ${m}$ to ${m = 8,}$ and we move to the next
node. Test: ${8 < 12?}$

<LinkedList data={["root", 3, 5, 8, { val: 12, ant: "p" }, 16]} />

Yes. Now ${m = 12.}$ Move to the next and test: ${12 < 16?}$

<LinkedList data={["root", 3, 5, 8, 12, 16]} />

Yes. We've reached the end of the list, so we can determine the list is
sorted. If any point we found that ${m \nleq n(d),}$ we would have
concluded that the list is not sorted.

In pseudocode:

```nasm
fn isSorted(Node* head) -> boolean
int currentMin = MIN_INT;
Node* p = head;
while (p != NULL):
	if (p->data < currentMin):
		return false;
	else:
		currentMin = p->data;
		p = p->next;
return true;
```

Here's an implementation in C++:

```cpp
bool isSorted() {
	int min = INT_MIN;
	Node* p = head;
	while (p != NULL) {
		if (p->data < min) {
			return false;
		} else {
			min = p->data;
			p = p->next;
		}
	}
	return true;
```

Testing this implementation:

```cpp
#include <iostream>
#include <stdbool.h>

struct Node {
	int data;
	Node* next;
	Node() {
		data = 0;
		next = NULL;
	}
	Node(int newData) {
		data = newData;
		next = NULL;
	}
};

class List {
	Node* head;
	Node* foot;
	public:
		List() {
			head = new Node();
			foot = head;
		}
		List(int data) {
			head = new Node(data);
			foot = head;
		}
		List(int arr[], int size) {
			head = new Node(arr[0]);
			foot = head;
			for (int i = 1; i < size; i++) {
				Node* freshNode = new Node(arr[i]);
				foot->next = freshNode;
				foot = freshNode;
			}
		}
		bool isSorted() {
			int min = INT_MIN;
			Node* p = head;
			while (p != NULL) {
				if (p->data < min) {
					return false;
				} else {
					min = p->data;
					p = p->next;
				}
			}
			return true;
		}
		void print() {
			Node* p = NULL;
			std::cout << "( ";
			if (head != NULL) {
				p = head;
				while (p->next != NULL) {
					std::cout << p->data << " ";
					p = p->next;
				}
			} else {
				std::cout << "empty";
			}
			std::cout << ")\n";
		}
};

int main() {
	int arr1[] = {1,2,3,4,5};
	int arr2[] = {1,2,8,4,5};
	List aList = List(arr1, 5);
	List bList = List(arr2, 5);
	aList.print();
	bList.print();
	std::cout << "Sorted: " << aList.isSorted() << std::endl;
	std::cout << "Sorted: " << bList.isSorted() << std::endl;
	return 0;
}
```

```bash
( 1 2 3 4 )
( 1 2 8 4 )
Sorted: 1
Sorted: 0
```

## Dedupe a Sorted List

Suppose we have the following linked list:

<LinkedList data={["root", 2, 4, 4, 8, 8, 8]} />

Notice that the list above is sorted, but we have duplicates: ${4}$ and
${8.}$ Many procedures require us to __dedupe__ (<q>deduplicate</q>) this
listâ€”removing nodes with duplicate values in their data fields.
Post-dedupe, we have the list:

<LinkedList data={["root", 2, 4, 8]} />

The most straightforward way to dedupe a linked list is to start with two
pointers, one pointing to the list's head, the other pointing the node
immediately after:

<LinkedList
	data={["root", { val: 2, ant: "t" }, { val: 4, ant: "d" }, 4, 8, 8, 8]}
/>

Once there, we ask: ${v(d) = v(d)?}$ Where ${v}$ is a function returning
the data value of the pointee node. If it does not match, then we move `d`
to its next node, and `t` its next node. With the pointers `d` and `t`
positioned, we check again, ${v(d) = v(t)?}$

<LinkedList
	data={["root", 2, { val: 4, ant: "t" }, { val: 4, ant: "d" }, 8, 8, 8]}
/>

Here, we see that ${v(d) = v(t),}$ since ${v(n_2) = 4 = v(n_3) = 4.}$ If
the nodes match, we want to delete `d`'s pointee.[^pointeenote] To do so,
we have `t`'s `next` field point to `d`'s next field. Then, we `delete`
`d`'s pointee. Then, we make `d`'s `next` point to `t`'s next. More
explicitly with pseudocode:

[^pointeenote]:
    We can delete either `t`'s pointee or `d`'s pointee; it makes no
    difference.

```nasm
fn dedupeSorted() -> void :
	Node* t = head;
	Node* d = head->next;
	while (d != NULL):
		if (t->data != d->data):
			t = d;
			d = d->next;
		else:
			t->next = d->next;
			delete d;
			d = t->next;
```

With this implementation, we must scan through the entire list of ${n}$
nodes to dedupe. As such, this approach has a time complexity of
${O(n)}$â€”linear time. Because the procedure must <em>always</em> traverse
the entire linked list to dedupe, the time complexity is always ${O(n).}$

Here's an implementation in C:

```c
void dedupe(struct Node **head) {
	struct Node *t = *head;
	struct Node *d = (**head).next;
	while (d != NULL) {
		if ((*t).data != (*d).data) {
			t = d;
			d = (*d).next;
		} else {
			(*t).next = (*d).next;
			free(d);
			d = (*t).next;
		}
	}
}

// The function call:
dedupe(&list);
```

Let's go through this code carefully. First:

```c
void dedupe(struct Node **head)
```

The function header provides that `dedupe()` returns nothing, and takes as
an argument the memory address of a pointer. The identifier `head` is a
pointer to a pointer. In this case, `**head = &list = &(Node *${p}$)`,
where ${p}$ is the pointer to some node.

```c
struct Node *t = *head;
```

The contents of `head`, i.e., the address stored in `head`, is stored in
`t`. In other words, `t` points to the address stored in `head`, which is
`&list`.

```c
struct Node *d = (**head).next
```

The pointer `d` points to the address stored in `head`'s `next` field. This
is the next field of the original list's head.

```c
while (d != NULL)
```

"As long as `d`'s pointee is a valid address."

```c
if ((*t).data != (*d).data)
```

If the data in `t` (the data in the original list's head) is not equal to
the data in `d` (in the original list, the node immediately after the
head).

```c
t = d
```

The address in `d` is now the address in `t`. I.e., the pointer `t` now
points to the node immediately after its previous pointee.

```c
d = (*d).next
```

The address stored in `d`'s next field is now the address of `d`.

```c
(*t).next = (*d).next
```

If the data in `t` is not equal to the data in `d`, then the address in
`d`'s next field becomes the address in `t`'s next field.

```c
free(d)
```

Free the memory `d` points to.

```c
d = (*t).next
```

The address in `t`'s next field becomes the address in `d`.

Testing the implementation above:

```c
#include <stdlib.h>
#include <stdio.h>

struct Node {
	int data;
	struct Node *next;
};

struct Node *newNode(int newData) {
	struct     Node *newNode = malloc(sizeof(struct Node));
	(*newNode).data          = newData;
	(*newNode).next          = NULL;
	return newNode;
}

struct Node *List(int arr[], int arrSize) {
	if (arrSize <= 0) {
		return NULL;
	} else {
		struct Node* head = newNode(arr[0]);
		struct Node* foot = head;
		for (int i = 1; i < arrSize; i++) {
			struct Node* freshNode = newNode(arr[i]);
							foot->next      = freshNode;
							foot            = freshNode;
		}
		return head;
	}
}

void print(struct Node *headRef) {
	struct Node* foot = headRef;
	printf("( ");
	while (foot != NULL) {
		printf("%d ", foot->data);
		foot = foot->next;
	}
	printf(")\n");
}

void dedupe(struct Node **head) {
	struct Node *t = *head;
	struct Node *d = (**head).next;
	while (d != NULL) {
		if ((*t).data != (*d).data) {
			t = d;
			d = (*d).next;
		} else {
			(*t).next = (*d).next;
			free(d);
			d = (*t).next;
		}
	}
}

int main() {
	int    size       = 6;
	int    arr[]      = {1,3,3,8,8,8};
	struct Node *list = List(arr, size);
	print(list);
	dedupe(&list);
	print(list);
	return 0;
}
```

```bash
( 1 3 3 8 8 8 )
( 1 3 8 )
```

## Concatenating Lists

Say we had the following lists:

<LinkedList data={["list1", 1, 2, 3]} />
<LinkedList data={["list2", 4, 5, 6]} />

We want to take these one of these two lists, and _concatenate_ it with the
other. Suppose the function is called `concat()`. If we call
`concat(list1, list2)`, we get:

<LinkedList
	data={["list1", 1, 2, 3, 4, 5, 6]}
	width={360}
	containerWidth={110}
/>

And if we call `concat(list2, list1)`, we get:

<LinkedList
	data={["list2", 4, 5, 6, 1, 2, 3]}
	width={360}
	containerWidth={110}
/>

The procedure here is straightforward. If we call `concat(list1, list2)`
the `next` pointer for `list1`'s foot should point to `list2`'s head.
Hence, all that's required is to have a pointer on the first list
argument's foot. One way to do so is to initialize a pointer `p` initially
at `list1`'s head, then traverse the list to the foot. Once there, we have
`p`'s pointee point to `list2`'s head:

```nasm
fn concat(*Node list1, Node* list2) -> void:
	Node* p = list1;
	while (p -> next != NULL):
		p = p->next;
		p->next = list2;
```

Because we must traverse the list to find the first argument's foot, the
procedure above has a time complexity of ${O(n).}$ We can, of course,
reduce this to ${O(1)}$ if we ensure that every list we create contains
pointers to the foot and pointers to the head. In that case, all that's
required is to have the first list's foot's pointee's `next` field point to
the second list's head.

Here's an implementation in C:

```c
struct Node *concat(struct Node *list1, struct Node *list2) {
	struct Node *ptr;
	if (list1 == NULL) {
		list1 = list2;
		return list1;
	}
	if (list2 == NULL) {
		return list1;
	}
	ptr = list1;
	while ((*ptr).next != NULL) {
		ptr = (*ptr).next;
	}
	(*ptr).next = list2;
	return list1;
}
```

Testing the implementation above:

```c
#include <stdlib.h>
#include <stdio.h>

struct Node {
	int data;
	struct Node *next;
};

struct Node *newNode(int newData) {
	struct Node* freshNode = malloc(sizeof(struct Node));
	(*freshNode).data = newData;
	(*freshNode).next = NULL;
	return freshNode;
}

struct Node *List(int arr[], int size) {
	struct Node *head = newNode(arr[0]);
	struct Node *foot = head;
	for (int i = 1; i < size; i++) {
		struct Node *freshNode = newNode(arr[i]);
		(*foot).next = freshNode;
		foot = freshNode;
	}
	return head;
}

void print(struct Node *p) {
	printf("( ");
	if (p != NULL) {
		while (p != NULL) {
			printf("%d ", (*p).data);
			p = (*p).next;
		}
	} else {
		printf("empty ");
	}
	printf(")\n");
}

struct Node *concat(struct Node *list1, struct Node *list2) {
	struct Node *ptr;
	if (list1 == NULL) {
		list1 = list2;
		return list1;
	}
	if (list2 == NULL) {
		return list1;
	}
	ptr = list1;
	while ((*ptr).next != NULL) {
		ptr = (*ptr).next;
	}
	(*ptr).next = list2;
	return list1;
}

int main() {
	int arr1[] = {1,2,3};
	int arr2[] = {6,7,8};
	int arrSize = 3;
	struct Node* aList = List(arr1, arrSize);
	print(aList);
	struct Node* bList = List(arr2, arrSize);
	print(bList);
	struct Node* cList = concat(aList, bList);
	print(aList);
	return 0;
}
```

```bash
( 1 2 3 )
( 6 7 8 )
( 1 2 3 6 7 8 )
```

## Merging Lists

<p>We have the following linked lists:</p>

<LinkedList data={["list1", 2, 8, 10, 15]} />

<LinkedList data={["list2", 4, 7, 12, 14]} />

We want to take `list1` and `list2`, and _merge_ them into a single list,
where each node is sorted in increasing order. __Merging__ is the process
of combining two sorted lists into a single sorted list. Recall that when
we merged two arrays, we required a third array. With linked lists, there
is no such requirement. We just have to manipulate the links (of course, we
could always create a new list to return).

To merge two lists, we need two more pointers, will call one of them `h`
and the other `t`. The pointer `h` will point to the merged list's head,
and the pointer `t` will point to the merged list's tailend.

The procedure is as follows: First, compare the data value stored in
`list1`'s head with the data value stored `list2`'s head.

<LinkedList data={["list1", { val: 2, focus: true }, 8, 10, 15]} />

<LinkedList data={["list2", { val: 4, focus: true }, 7, 12, 14]} />

Between the two data values, the node containing the smaller data value
becomes the pointee of both `h` and `t`. Here, that node is `list1`'s head:

<LinkedList data={["list1", { val: 2, ant: "h t" }, 8, 10, 15]} />

<LinkedList data={["list2", { val: 4, focus: true }, 7, 12, 14]} />

Then, we move the head pointer of `list1` to the next node:

<LinkedList
	data={[
		"list1",
		{ val: 2, ant: "h t" },
		{ val: 8, ant: "list1" },
		10,
		15,
	]}
/>

<LinkedList data={["list2", 4, 7, 12, 14]} />

Then, we go to the node `h` and `t` point to, and sets its `next` field
`NULL`.

<LinkedList
	data={[
		"list1",
		{ val: 2, ant: "h t", alone: true },
		{ val: 8, ant: "list1" },
		10,
		15,
	]}
/>

<LinkedList data={["list2", 4, 7, 12, 14]} />

Then we continue the comparison. We compare the current pointee of `list1`
against the head of `list2`:

<LinkedList
	data={[
		"list1",
		{ val: 2, ant: "h t", alone: true },
		{ val: 8, ant: "list1", focus: true },
		10,
		15,
	]}
/>

<LinkedList data={["list2", { val: 4, focus: true }, 7, 12, 14]} />

Here, we see that `list2`'s pointee stores a lesser data value than
`list1`'s pointee. Because of this fact, we go to the node that `h` and `t`
point to, and make its `next` pointer point to `list2`. After doing so, we
bring `t` `list2`'s pointee.

<LinkedList
	data={[
		"list1",
		{ val: 2, ant: "h", alone: true },
		{ val: 8, ant: "list1", focus: true },
		10,
		15,
	]}
/>

<LinkedList data={["list2", { val: 4, ant: "t" }, 7, 12, 14]} />

Then, we'll have `list2` point to its `next` pointee:

<LinkedList
	data={[
		"list1",
		{ val: 2, ant: "h", alone: true },
		{ val: 8, ant: "list1", focus: true },
		10,
		15,
	]}
/>

<LinkedList
	data={["list2", { val: 4, ant: "t" }, { val: 7, ant: "list2" }, 12, 14]}
/>

Then we make `t`'s pointee's `next` pointer `NULL`:

<LinkedList
	data={[
		"list1",
		{ val: 2, ant: "h", alone: true },
		{ val: 8, ant: "list1", focus: true },
		10,
		15,
	]}
/>

<LinkedList
	data={[
		"list2",
		{ val: 4, ant: "t", alone: true },
		{ val: 7, ant: "list2" },
		12,
		14,
	]}
/>

We continue the procedure. Compare `list1`'s pointee against `list2`'s
pointee.

<LinkedList
	data={[
		"list1",
		{ val: 2, ant: "h", alone: true },
		{ val: 8, ant: "list1", focus: true },
		10,
		15,
	]}
/>

<LinkedList
	data={[
		"list2",
		{ val: 4, ant: "t", alone: true, focus: true },
		{ val: 7, ant: "list2" },
		12,
		14,
	]}
/>

Here, `list2`'s pointee is smaller. So, we move `t` to `list2`'s pointee:

<LinkedList
	data={[
		"list1",
		{ val: 2, ant: "h", alone: true },
		{ val: 8, ant: "list1", focus: true },
		10,
		15,
	]}
/>

<LinkedList
	data={[
		"list2",
		{ val: 4, alone: true, focus: true },
		{ val: 7, ant: "t list2" },
		12,
		14,
	]}
/>

Then we assign `list2` to as the last node's `next` pointee:

<LinkedList
	data={[
		"list1",
		{ val: 2, ant: "h", alone: true },
		{ val: 8, ant: "list1", focus: true },
		10,
		15,
	]}
/>

<LinkedList
	data={[
		"list2",
		{ val: 4, alone: true, focus: true },
		{ val: 7, ant: "list2" },
		{ val: 12, ant: "t" },
		14,
	]}
/>

Followed by moving `t` to `list2`'s `next` pointee, and `list2` thereafter
to `t`'s `next`

<LinkedList
	data={[
		"list1",
		{ val: 2, ant: "h", alone: true },
		{ val: 8, ant: "list1", focus: true },
		10,
		15,
	]}
/>

<LinkedList
	data={[
		"list2",
		{ val: 4, alone: true, focus: true },
		{ val: 7 },
		{ val: 12, ant: "list2 t" },
		14,
	]}
/>

We then make `t`'s pointee's `next` pointer `NULL`:

<LinkedList
	data={[
		"list1",
		{ val: 2, ant: "h", alone: true },
		{ val: 8, ant: "list1", focus: true },
		10,
		15,
	]}
/>

<LinkedList
	data={[
		"list2",
		{ val: 4, alone: true, focus: true },
		{ val: 7 },
		{ val: 12, ant: "list2 t", alone: true },
		14,
	]}
/>

We continue the procedure above so long as the pointers `list1` and `list2`
are nonnull pointers. Otherwise, we stop. Continuing the procedure above,
we will eventually get to a point where `list2` is `NULL` before `list1`.
When this occurs, we have `t` pointing to the last node in `list2`. All we
must do in this case is to have `t`'s pointee point to `list1`'s pointee.
In doing so, we have the following:

<LinkedList data={[2, 4, 7, 8, 10, 12, 14, 15]} />

Implementing this in pseudocode:

```nasm
fn sortedMerge(Node* list1, Node* list2) -> Node*:
	Node* newHead = new Node()
	Node* newTail = newHead;
	while (list1 != NULL && list2 != NULL):
		if (list1->data &lt; list2->data):
			newTail->next = list1;
			list1 = list1->next;
		else:
			newTail->next = list2;
			list2 = list2->next;
	if (list1 == NULL):
		newTail->next = list2;
	else:
		newTail->next = list1;
	return newHead->next;
```

As we can see, linked lists are suitable for merging. This is because we do
not require so much additional space, as we see with merging arrays.
Merging with both linked lists and arrays takes linear timeâ€”${O(n)}$â€”since
we must traverse the lists or arrays (or, more accurately, ${O(m + n) }$).
As such, between the two, linked lists have the upper-hand for merging,
given the reduced amount of space consumed.

Here's an implementation in C:

```c
struct Node *merge(struct Node *list1, struct Node *list2) {
	struct Node *newHead = malloc(sizeof(struct Node));
	struct Node *newTail = newHead;
	while (list1 != NULL && list2 != NULL) {
		if ((*list1).data < (*list2).data) {
			(*newTail).next = list1;
			list1 = (*list1).next;
		}
		else {
			(*newTail).next = list2;
			list2 = (*list2).next;
		}
		newTail = (*newTail).next;
	}
	if (list1 == NULL) {
		(*newTail).next = list2;
	} else {
		(*newTail).next = list1;
	}
	return (*newHead).next;
}
```

Testing this implementation:

```c
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

struct Node {
	int data;
	struct Node *next;
};

struct Node *newNode(int val) {
	struct Node *freshNode = malloc(sizeof(struct Node));
	(*freshNode).data = val;
	(*freshNode).next = NULL;
	return freshNode;
}

struct Node *List(int arr[], int size) {
	struct Node *head = newNode(arr[0]);
	struct Node *foot = head;
	for (int i = 1; i < size; i++) {
		struct Node *freshNode = newNode(arr[i]);
		(*foot).next = freshNode;
		foot = freshNode;
	}
	return head;
}

void print(struct Node *list) {
	if (list != NULL) {
		printf("( ");
		while (list != NULL) {
			printf("%d ", (*list).data);
			list = (*list).next;
		}
		printf(")\n");
	}
	else {
		printf("List is empty.\n");
	}
}

struct Node *merge(struct Node *list1, struct Node *list2) {
	struct Node *newHead = malloc(sizeof(struct Node));
	struct Node *newTail = newHead;
	while (list1 != NULL && list2 != NULL) {
		if ((*list1).data < (*list2).data) {
			(*newTail).next = list1;
			list1 = (*list1).next;
		}
		else {
			(*newTail).next = list2;
			list2 = (*list2).next;
		}
		newTail = (*newTail).next;
	}
	if (list1 == NULL) {
		(*newTail).next = list2;
	} else {
		(*newTail).next = list1;
	}
	return (*newHead).next;
}

int main() {
	int arr1[] = {1,3,8,9};
	int arr2[] = {2,7,11,13};
	int size = 4;
	struct Node *aList = List(arr1, size);
	struct Node *bList = List(arr2, size);
	struct Node *cList = merge(aList, bList);
	print(cList);
	return 0;
}
```

```bash
( 1 2 3 7 8 9 11 13)
```

## Loop Detection

<p>Consider the following linked list:</p>

<CircularList data={[8, 5, 4, 7, 3, 9]} />

Unlike the other linked lists we've seen, this linked list contains a link
to itself. If we follow the arrows, we see that ${(n \mid 8)}$ is connected
to ${(n \mid 5),}$ which is connected to ${(n \mid 4),}$ which is connected
to ${(n \mid 7),}$ then ${(n \mid 3),}$ then the foot, ${(n \mid 9.)}$ The
foot, however, has a nonnull next pointerâ€”it points to ${(n \mid 4).}$

In graph theory, we say that this linked list contains a __loop__. With
linked lists, a loop occurs when the last node in the linked listâ€”the
footâ€”points to a node in the linked list. When a linked list contains a
loop, we say that the linked list is __non-linear__. Otherwise, the linked
list is __linear__. For example, if the linked list above was linear, we
would have:

<LinkedList
	data={["root", 8, 5, 4, 7, 3, 9]}
	width={320}
	containerWidth={100}
/>

Many algorithms depend on the assumption that the linked list it operates
on is linear or non-linear. Accordingly, it's helpful to have a **loop
detector**â€”an algorithm that determines whether or not a linked list
contains a loop.

Determining whether a given list is linear is simple. We just have to check
whether the foot's `next` field is the null pointer. This approach,
however, does not allow us to immediately conclude if the list is
non-linear. Why? Because we would need to use a loop to traverse the array.
So far, we've been terminating those loops by relying on the assumption
that the foot's `next` pointer is the null pointer. We do not have that
benefit here. If the foot's `next` pointer points to some node in the list,
we enter an infinite loop. As such, we must think of another approach to
loop detection.

One approach is to use two pointers, `d` and `t`, both initially at the
list's head:

<CircularList data={[{ val: 8, ant: "d t" }, 5, 4, 7, 3, 9]} />

With the pointers set, we enter a while loop: At each iteration, we move
`t` by one node, and `d` by two nodes:

<CircularList
	data={[{ val: 8, ant: "t" }, { val: 5, ant: "d" }, 4, 7, 3, 9]}
/>

So long as `d` and `t` are not pointing at the same node, we continue the
movement:

<CircularList
	data={[8, 5, { val: 4, ant: "t" }, 7, { val: 3, ant: "d" }, 9]}
/>

We move again, `t` by one, `d` by two. This brings `d` to ${(n \mid 4),}$
the node the foot points to:

<CircularList
	data={[8, 5, { val: 4, ant: "d" }, { val: 7, ant: "t" }, 3, 9]}
/>

<p>We move once more:</p>

<CircularList data={[8, 5, 4, 7, { val: 3, ant: "t d" }, 9]} />

With this last movement, we've reached a point where both `d` and `t` point
to the same node. And if that occurs, we know we're dealing with a
non-linear listâ€”there's a loop.

The procedure:

```nasm
fn isLinear(Node* list) -> bool :
	Node* d;
	Node* t;
	d = t = list;
	do:
		t = t->next;
		d = d->next;
		t = t ? (*t).next : t;
		else: d = NULL;
		while (p && q && p != q);
	if (p == q): return false;
	else: return true;
```

Examining this approach, we can see that the procedure has a time
complexity of ${O(n).}$ We must traverse ${n}$ nodes to determine whether
the given linked list is linear or non-linear.[^alternative_note]

[^alternative_note]:
    As usual, we can perform a loop detection in ${O(1)}$ time if we
    maintain a pointer to the foot of every list we create. In that
    situation, all we must do is check if that pointer is equal to `NULL`.
    The tradeoff, however, is in memory consumption.

Here's an implementation in C:

```c
int isLinear(struct Node* list) {
	struct Node* d;
	struct Node* t;
	d = t = list;
	do {
		t = (*t).next;
		d = (*d).next;
		t = t ? (*t).next : t;
	} while (d && t && d != t);
	if (d == t) {
		return 0; // false
	} else {
		return 1; // true
	}
}
```

Testing this program:

```c
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

struct Node {
	int data;
	struct Node* next;
};

struct Node* newNode(int val) {
	struct Node* node = malloc(sizeof(struct Node));
	(*node).data = val;
	(*node).next = NULL;
	return node;
}

void print(struct Node* p) {
	printf("( ");
	while (p != NULL) {
		printf("%d ", (*p).data);
		p = (*p).next;
	}
	printf(")\n");
}

int isLinear(struct Node* list) {
	struct Node* d;
	struct Node* t;
	d = t = list;
	do {
		t = (*t).next;
		d = (*d).next;
		t = t ? (*t).next : t;
	} while (d && t && d != t);
	if (d == t) {
		return 0; // false
	} else {
		return 1; // true
	}
}

int main() {
	struct Node* list1 = newNode(8);
	struct Node* n1 = newNode(5);
	struct Node* n2 = newNode(4);
	struct Node* n3 = newNode(7);
	struct Node* n4 = newNode(3);
	struct Node* n5 = newNode(9);
	(*list1).next = n1;
	(*n1).next = n2;
	(*n2).next = n3;
	(*n3).next = n4;
	(*n4).next = n5;
	(*n5).next = n2;
	int list1Linear = isLinear(list1);
	printf("%d\n", list1Linear);
	return 0;
}
```

```bash
0
```

If we comment out the last link, `(*n5).next = n5`, we will see `1` as the
outputâ€”`list1` is linear.
