import { Sequence, StaticArray } from "../../../components/hago";

# Common Problems

These notes cover some common algorithmic problems.

## Pairs

Consider the following problem:

> Given an array containing ${n}$ integers and a target sum ${S,}$ find two
> distinct integers that, when added, result in ${S.}$ Assume there is only
> one such pair.

**Brute Force Approach.** We can solve this problem with a brute force
approach:

```rust
pairSum(array: number[], target:number):
  let L = array.length;
  for (let i = L; i > 0; i--):
    for (let j = 0; j < i-1; j++):
      let a = array[i-1];
      let b = array[j]
      let sum = a + b
      if (sum == target && a !== b):
        return [a, b];
  return [];
```

Here, we iterate from the start to the end, and within each loop, we
iterate from the end to the start. If we find that the elements sum to the
target, _and_ the elements are distinct, we return the pair. Otherwise, we
continue. Say we called this function on:

```rust
pairsum([10,5,2,3,-6,9,11], 4)
```

Tracing the code:

| pass | step | array[i] | array[j] | sum | match   |
| ---- | ---- | -------- | -------- | --- | ------- |
| 0    | 0    | 11       | 10       | 21  |         |
|      | 1    | 11       | 5        | 16  |         |
|      | 2    | 11       | 2        | 13  |         |
|      | 3    | 11       | 3        | 14  |         |
|      | 4    | 11       | -6       | 5   |         |
|      | 5    | 11       | 9        | 20  |         |
| 1    | 6    | 9        | 10       | 19  |         |
|      | 7    | 9        | 5        | 14  |         |
|      | 8    | 9        | 2        | 11  |         |
|      | 9    | 9        | 3        | 12  |         |
|      | 10   | 9        | -6       | 3   |         |
| 2    | 11   | -6       | 10       | 4   |         |
|      | 12   | -6       | 5        | -1  |         |
|      | 13   | -6       | 2        | -4  |         |
|      | 14   | -6       | 3        | -3  |         |
|      | 15   | -6       | 3        | -3  | (-6,10) |

This is a straightforward approach, but it runs on ${O(n^2).}$

**Sort First.** Another option is to use binary search:

```rust
pairSum(array: number[], target: number):
  let sortedArray = sort(array)
  let high = array.length - 1
  let low = 0
  let key = target - arr[0]
  while (low <= high){
    const mid = floor((low + high) / 2)
    const guess = arr[mid]
    if (guess === key) {
      return [arr[0], guess]}
    else if (guess > key) {
      high = mid - 1}
    else {
      low = mid + 1}}
  return []
```

With this approach, we sort the array first. Once the array is sorted, we
set the first element (or any element for that matter), as one of the
supposed pair's elements. The key is then:

$$
  \tt{query} = \tt{target} - \tt{arr[0]}
$$

Because the array is sorted, we do not have to check all the possible
combinations.

| step         | low        | high       | mid        | guess      | match      |
| ------------ | ---------- | ---------- | ---------- | ---------- | ---------- |
| sorting time | ${\vdots}$ | ${\vdots}$ | ${\vdots}$ | ${\vdots}$ | ${\vdots}$ |
| 1            | 4          | 6          | 3          | 5          |            |
| 2            | 4          | 6          | 5          | 10         | (-6,10)    |

With this approach, it only takes two steps to find a match, compared with
15 in the previous approach. The caveat, of course, is that `sort()`
function call. The time it takes to find the pair, then, is of the order:

$$
  O(n \log n) + O_{\tt{sort}}
$$

where ${O_S}$ is the time complexity of the sorting algorithm. A slow
sorting algorithm, e.g., a basic linear search, will yield a longer
execution time.

**Leverage a Data Structure.** A faster approach is to leverage a data
structure:

```rust
pairSum(array: number[], target: number):
  let set = new Set()
  for (let i = 0, i < array.length, i++) {
    let diff = target - array[i]
    if (set.has(diff)) {
      return [array[i], diff]
    }
    else {
      set.add(array[i])
    }
  }
  return [];
```

Above, `new Set()` returns some hash table, binding it to `set`. Because
`set` is a hash table, checking whether the difference exists in the set
takes ${O(1)}$ time. Accordingly, this approach has a time complexity of
${O(n),}$ which is, in fact, faster than ${O(n^2)}$ and ${O(n \log n).}$

## Magic Triplets

The triplet problem goes as follows:

> Given an array containing ${n}$ integers, find all unique triplets that
> summate to zero. Both the triplets and their elements should be returned
> in ascending order. If no such triplets exist, return an empty array.

**Brute Force Approach.** Once more, the most straightforward approach is
brute-force.

```rust
triplets(array: number[], target: number):
  let result = []
  const L = array.length
  sort(array)
  for (let i = 0; i < L - 2; i++) {
    for (let j = i + 1; j < L - 1; j++) {
      for (let k = j + 1; k < L; k++) {
        let a = array[i]
        let b = array[j]
        let c = array[k]
        if (a + b + c === 0) result.push([a, b, c])
      }
    }
  }
  return result
```

But again, this puts us in ${O(n^3)}$ territory. The sorting step is likely
negligble, considering the fact that we're running on cubic time.

**Using a Hash Table.** We could use a hash table:

```rust
triplets(array):
  sort(array)
  let out = []
  for (let i = 0; i < array.length - 1; i++) {
    let hashTable = HashTable()
    for (let j = i + 1; j < array.length; j++) {
      let sum = -(array[i] + array[j])
      if (hashTable.has(sum)) {
        out.push([sum, array[i], array[j]])
      }
      else {
        hashTable.add(array[j])
      }
    }
  }
  return out
```

Notice that in the code above we have two loops. Suppose we called the
function on:

$$
  [-2,6,1,2,-1,-4,0]~~(\tt{length}=7)
$$

The loop works by running from the start to the end. Then, at each
iteration, we start at the element just ahead (`j=i+1`). We then compute
the negated sum of the two elements: ${-(n_i + n_{i+1}).}$ This step is
necessary because we're looking for the third element in the triplet. That
is, the element such that:

$$
  0 = n_i + n_{i+1} + n_{i+2}
$$

which is:

$$
  -(n_i + n_{i+1}) = n_{i+2}
$$

The problem with this approach: It runs on ${O(n^2).}$

**Indexing Approach.** We can somewhat mitigate the efficiency by using
additional memory. To do so, we'll use an alternative version of the pair
sum function we saw earlier:

```rust
allPairSum(array, target):
  sort(array)
  const out = []
  let p = 0
  let q = array.length - 1
  for (let i = 0, i < array.length, i++) {
    let n = array[p]
    let m = array[q]
    let sum = n + m
    (sum === target) && out.push([n, m]) && (p++) && (q--)
    (sum < target) && (p++)
    (sum > target) && (q--)
  }
  return out
```

Above, we use two variables, `p` and `q`. One variable starts at 0, the
other starts at `array.length-1` (the last valid index in the array). Using
these two additional variables, we can now traverse the array from both the
start and the end. At each iteration, we compute `sum = n+m`.

If the sum is the target, we insert it into the `out` array, increment `p`,
and decrement `q`. We change both of these indexing variables because we
want to gather _all_ of the tuples. If it isn't, then we have two cases:

- Case 1: The sum is less than the target, or
- Case 2: The sum is greater than the target.

Because the array is sorted, we can draw further inteferences from the
cases:

- Case 1 ${\implies}$ `n` is not big enough.
- Case 2 ${\implies}$ `m` is too big.

Accordingly, we make the necessary changes. Note that we're using the
logical-and as a shortcuit. Extending this logic to triplets is trivial:

```rust
triplets(array):
  sort(array)
  let arrayLength = array.length - 1
  let out = []
  let p = 0
  let q = arrayLength
  let target = 0 - array[0]
  for (let i = 0, i < arrayLength, i++) {
    let n = array[p]
    let m = array[q]
    let s = n + m
    (s === target) && out.push([array[0], n, m]) && (p++) && (q--)
    (s < target) && (p++)
    (s > target) && (q--)
  }
  return out
```

The time complexity of this approach entirely depends on the `sort()`
function's implementation.

## Mountains

In number theory, a **mountain** is defined as a sequence of adjacent
integers that strictly increase towards a bigger integer (called a _peak_),
and thereafter become strictly decreasing. At least three integers are
required to form a mountain. For example, given the sequence:

$$
  \seq{1,0,3,5,10,8}
$$

a mount exists in the sub-sequence:

$$
  \seq{5,10,8}
$$

Given this definition, here is the problem:

> Given an array of distinct integers, find the length of the highest
> mountain.

**Brute Force.** As usual, the simplest approach is brute force:

```rust
mountains(array: number[]):
  let max = 0
  const L = array.length
  for (let i = 1; i < L-1; i++) {
    if (array[i] > array[i - 1] AND array[i] > array[i + 1]) {
      let count = 1
      let j = i
      let k = i
      while (j >= 1 AND array[j] > array[j - 1]) {
        j--
        count++
      }
      while (k <= L - 2 AND array[k] > array[k + 1]) {
        k++
        count++
      }
      max = count > max ? count : max
    }
  }
  return max
```

To illustrate how this code works, consider the input:

<StaticArray
	data={[5, 6, 1, 2, 3, 4, 5, 4, 3, 2, 0, 1, 2, 3, -2, 4]}
	cheight={0.2}
/>

Using a lollipop chart, we can better visualize the peaks:

<Sequence
	data={[
		[1, 5],
		[2, 6],
		[3, 1],
		[4, 2],
		[5, 3],
		[6, 4],
		[7, 5],
		[8, 4],
		[9, 3],
		[10, 2],
		[11, 0],
		[12, 1],
		[13, 2],
		[14, 3],
		[15, -2],
		[16, 4],
	]}
	scale={70}
/>

Here, we have a peak at 2, 5, and 4. When we get to 2, we count backwards
to 1 (the start of the mountain) and forward to 3 (the end of the
mountain). This gives us a length of 3. When we get to 5, we perform the
same procedure. We count backwards to 1, and forwards to 0. This gives us a
length of 9.

Returning to the code:

```rust
mountains(array: number[]):
  let max = 0
  const L = array.length
  for (let i = 1; i < L-1; i++) {
    if (array[i] > array[i - 1] AND array[i] > array[i + 1]) {
      let count = 1
      let j = i
      let k = i
      while (j >= 1 AND array[j] > array[j - 1]) {
        j--
        count++
      }
      while (k <= L - 2 AND array[k] > array[k + 1]) {
        k++
        count++
      }
      max = count > max ? count : max
    }
  }
  return max
```

Notice that we start the index at `i=1`, and end at `i = L - 1`, where `L`
is the length of the array. We use these bounds because we use the index
`i` to determine whether a given element is a peak. And, from the
definition of a mountain, a peak exists if, and only if, it has an integer
to its left and an integer to its right. Therefore, the first element
cannot be a peak (since it has no integer to its left), nor can the last
(since it has no integer to its right).

Now, because our bounds run from `i = 1` to `i = L - 1`, we must take care
in accessing the left and right neighbors. To access the left neighbor, we
use the index `j`. And to access the right neighbor, we use the index `k`.
Because the `j` reads the element to the left, we have to make sure it
doesn't become the index `0`. This is because of the while-loop's test
condition:

```rust
(j >= 1 AND array[j] > array[j - 1])
```

If `j = 0`, then `array[j-1] = array[-1]`, which will result in a
segmentation fault. Similarly, for `k`, we must ensure that `k` doesn't
become `L-1`. Once again, this is because of its while-loop's test
condition:

```rust
(k <= L - 2 AND array[k] > array[k + 1])
```

If `k` becomes `L-1`, then we have `array[k+1] = array[L]`, which is an
invalid index. There is an optimization we can make to the code above:

```rust
mountains(array: number[]):
  let max = 0;
  const L1 = array.length - 1
  const L2 = array.length - 2
  for (let i = 1; i < L1; ) {
    if (array[i] > array[i - 1] AND array[i] > array[i + 1]) {
      let count = 1
      let j = i
      while (j >= 1 AND array[j] > array[j - 1]) {
        j--
        count++
      }
      while (i <= L2 AND array[i] > array[i + 1]) {
        i++
        count++
      }
      max = count > max ? count : max
    }
    else { i++ }
  }
  return max
```

First, the we declare `L1` (the last valid index) and `L2` (the second to
the last valid index) as constants. This helps with caching, and removes
the repeated operation of substraction. Next, we remove the variable `k`,
and simply use `i`. This is because `i` looks for peaks. By incrementing
`i` towards the end of a mountain, we know that `i` lands at an index that
is _not_ a peak. And since we're already incrementing `i` in the forward
count, we can move the for-loop's incrementing step into the loop's body.

## Belt Finding

In number theory, a **band** is a subsequence of an integer sequence that
can be reordered in a way that all elements in the subsequence have, at
most, an absolute difference of 1 between them. The longest band in an
integer sequence is called a **belt**.

For example, given the integer sequence:

$$
  \seq{1,9,3,0,18,5,2,4,10,7,12,6}
$$

There exists a belt:

$$
  \seq{0,1,2,3,4,5,6,7}
$$

There's also a band of length 2:

$$
  \seq{9,10}
$$

And two bands of length 1:

$$
  \seq{12} \\
  \seq{18}
$$

With that definition, here is the problem statement:

> Given an array of integers, find the length of a belt.

**Sorting.** The most straightforward approach to this problem is to sort
the elements first:

```rust
beltFinder(array: number[]):
  array = sort(array)
  const L = array.length
  let belt = 0
  for (let i = 0; i < L; i++) {
    let newBelt = 1
    while (i + 1 < L && array[i + 1] - array[i] === 1) {
      newBelt++
      belt = newBelt > belt ? newBelt : belt
      i++
    }
  }
  return belt
```

The advantage to this approach: (1) It's short and easy to understand, and
(2) it's memory efficient. The cost: there's a bottleneck at the `sort()`
call. Depending on how that function is implemented, we're likely placed in
${O(n \log n)}$ territory. Thus, while the loop itself takes ${O(n),}$ the
sorting method will more than likely swallow that up.

**Leverage a Hash Table.** A potentially better use of memory, while
maintaining linear time, is to use a hash table instead:

```rust
beltFinder(array: number[]):
  let table = hashTable()
  let belt = 0
  const L = array.length
  for (let i = 0; i < L; i++) {
    table.add(array[i]);
  }
  for (let i = 0; i < L; i++) {
    let leftNeighbor = array[i] - 1
    if (table.doesntHave(leftNeighbor)) {
      let rightNeighbor = array[i] + 1
      let count = 1
      while (table.has(rightNeighbor)) {
        rightNeighbor++
        count++
      }
      (count > belt) && (belt = count)
    }
  }
  return band
```

Here, the idea is to first add all of the array's elements to a hash table.
Then, we iterate over the array. At each given element, we determine that
element's `leftNeighbor`. That is, the integer that comes just before the
element. For example, if the element is 1, its left neighbor is 0. If the
element is 9, its left neighbor is 8.

Next, we check if the table _does not contain_ the left neighbor. Why?
Because if the table contains the element's left neighbor, then the element
cannot be the start of a band. Remember, we're asked to find the length of
a belt. That means the belt's starting element can't have a left neighbor.
If it does have a left neighbor, then it is inside a belt.

If we find that the element has no left neighbor, then it's the start of a
band (and potentially a belt), so we enter the if-block. There, we compute
the right neighbor. This is the integer that comes immediately after the
element. For example, if the element is 5, the right neighbor is 6. And if
the element is 6, the right neighbor is 7.

Once we compute the right neighbor, we start a counter at 1. Then, so long
as the table contains the element's right neighbor, we increment the count
and the right neighbor.

Once all of that is done, we execute a shortcircuit-and. If the count is
greater than the belt, we assign the new count to belt. Otherwise, we make
no such assignment and continue in the for-loop.

The advantage to this approach: We stay in ${O(n)}$ time. The cost: We
consume ${O(n)}$ memory for the hashTable. Given a sufficiently large
array, the hash table could be potentially huge.

**Utilizing a Bitset**. We can mitigate the memory cost substantially by
simply manipulating a bitset. Note that this implementation requires
substantially more code. The code below assumes a C++-like syntax:

```rust
int getBit(int n, int i):
  int mask = (1 << i)
  return (n & mask) > 0 ? 1 : 0

void setBit(int &n, int i):
  int mask = (1 << i)
  n = (n|mask)

int findMax(Ints &arr):
  size_t length = arr.size()
  int max = INT_MIN
  for (int i = 0; i < length; i++) {
    max = arr[i] > max ? arr[i] : max;
  }
  return max

int findMin(Ints &arr):
  size_t length = arr.size()
  int min = INT_MAX
  for (int i = 0; i < length; i++)
    min = arr[i] < min ? arr[i] : min
  return min

int beltFinder(Ints &arr)
  int intMax = sizeof(int) * 8
  int L = arr.size()
  int min = findMin(arr)
  int max = findMax(arr)
  int B = max - min + 1
  int arrSize = ((int)(B / intMax))+1
  int bitset[arrSize]
  for (size_t i = 0; i < arrSize; i++) {
    bitset[i] = 0
  }
  for (size_t i = 0; i < L; i++) {
    int v = arr[i] - min
    int b = v / intMax
    v < intMax ? setBit(bitset[b], v) : setBit(bitset[b], v % intMax)
  }
  int belt = 0
  int e
  for (size_t i = 0; i < B; i++) {
    int newBelt = 0
    int b = i / intMax
    int num = bitset[b]
    e = (i < intMax) ? getBit(num, i) : getBit(num, i % intMax)
    while (i < B && e == 1) {
      newBelt++
      i++
      e = (i < intMax) ? getBit(num, i) : getBit(num, i % intMax)
    }
    belt = newBelt > belt ? newBelt : belt
  }
  return belt
```

This approach takes advantage of the fact that we're considering integers.
To illustrate, say we passed the sequence:

$$
  \seq{1,9,3,0,18,5,2,4,10,7,12,6} ~~~ \tt{L = 12}
$$

The trick here is to first find the array's minimum and maximum elements:

$$
  \min = 0 \\
  \max = 18
$$

Next, we determine the value `B`:

$$
  \mm{B} = \max - \min + 1 = 18 - 0 + 1 = 19
$$

Using this value, we allocate a bitset of length `B`, all bits initialized
to zero:

<StaticArray
	data={[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
	cheight={0.15}
/>

We use these bits to track consecutive elements. Now, the challenge here is
that we're using bitwise operators. In most languages, these operators are
only defined (and with good reason) on integers. On most modern systems,
that integer has a maximum size of 4 bytes. Multiplying that by 8, we
get 32. This implies that we can only track the positions of up to 32
integers, at most. So, how do we get additional bits? We use a simple
array:

```rust
int arrSize = ((int)(B / intMax))+1
int bitset[arrSize]
for (size_t i = 0; i < arrSize; i++) {
  bitset[i] = 0
}
```

Here, we set the array's size to an integer division of `B` by the maximum
number of available bits (32). We then add 1 to this quotient. Why add 1?
Because if `B` is less than 32, then the integer division results in 0,
which is an invalid array size. Anything greater than 32 and we get 1, but
that's not enough. If we get 1, we want an array of size two, so as to get
32 additional bits.

Once we have an array of the appropriate size, we loop through the array,
initializing each element to 0:

```rust
for (size_t i = 0; i < arrSize; i++) {
  bitset[i] = 0
}
```

Then, we iterate over the array argument, computing `array[i] - min`. For
example, the first element is `1`, so we get:

$$
  1 - 0 = 1
$$

The second element is `9`, so get:

$$
  9 - 0 = 9
$$

We use this to index into the bitset, changing the values at that index to
`1`:

```rust
for (size_t i = 0; i < L; i++) {
  int v = arr[i] - min
  int b = v / intMax
  (v < intMax) ? setBit(bitset[b], v) : setBit(bitset[b], v % intMax)
}
```

Notice that we index differently, depending on whether `v`, the bitset
index, is less than maximum number of bits. If the value `v` is less than
32, we set the bit at the ${vth}$ position. However, in all other cases, we
set the bit at the `v` modulo `intMax` position. This ensures that when we
attempt to set the ${ith}$ bit, we only index within the range of 0 to 32.

This results in something that looks like:

<StaticArray
	data={[1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1]}
	cheight={0.15}
/>

Viewed this way, we see that the belt is the longest sequence of `1` bits.
What if the array contains a negative element? The approach still works.
All a negative element does is impact the the value of `B` (the bitset's
length). Say the input array contained `-1`. This would be the `min`, in
which we case we have:

$$
  \mm{B} = \max - \min + 1 = 18 - (-1) + 1 = 20
$$

When we get to calculating the index, we have:

$$
  \mm{v} = (-1) - (-1) = 0
$$

All the bitset does is track the adjacency of elements in the sequence.
It's _not_ a mapping of the indices to the actual array elements.

Now we just have to find the longest sequence of `1`s in the bitset. At
first glance, this doesn't seem like much of an imprvement. We stay in
${O(n)}$ time, but our memory consumption is still at ${O(n).}$ This is
because the amount of memory we consume is:

$$
  \floor{ \dfrac{\max - \min + 1}{\text{INT}} } + 1
$$

where ${\max}$ is the largest element in the array, ${\min}$ is the
smallest, and ${\text{INT}}$ is the size of an integer on the given system.
Given that ${\text{INT}}$ is a constant, factoring this term (along with
the other constants) yields the variable expression ${\max - \min.}$

So why go through this hassle? In practice, that bitset is undoubtedly
smaller than the hash table. Given an integer sequence of ${30~000}$ unique
elements, the approach above requires an array of size 938. Moreover, that
array is contiguous, and indexing into the array utilizes fast bitwise
operators. Compare that to a hash table with ${30~000}$ entries (alongside
the fact that the table likely also requires additional pointers), and it
isn't that difficult to see why the approach above might be more memory
efficient.

Now, what's the catch? Well, for starters, the code above is both
substantially longer and more difficult to read. That affects both
maintainability and generality. Second, we have several linear
dependencies: `findMin` and `findMax`. Both of those functions run on
linear time. In practice, this can be a significant bottleneck. We're
executing far more steps with this approach (we're relying on 5 separate
for-loops, compared to just 2 with the hash table).

## Hole Filling

Here is an interesting problem relevant to civil engineering:

> Given ${n}$ non-negative integers representing an elevation map, where
> the width of each bar is 1, compute how much water the map can trap after
> a rainstorm.

This problem is best read with a visual:

<Fig
	link={
		"https://res.cloudinary.com/sublimis/image/upload/v1660178444/cs/rains_sljkfh.svg"
	}
	imwidth={"369"}
	imheight={"176"}
	caption={"Hole filling"}
	width={"60"}
/>

What the problem tells us is that the visual above is represented by the
array:

$$
  [0,1,0,2,1,0,1,3,2,1,2,1]
$$

Each element in the array is a height. Based on that information, the
amount of water trapped is 6 (count the blue squares to verify).

### Check if an Array is Sorted Recursively

```rust
const A = [1, 2, 3, 4, 5];
const B = [3, 2, 5, 8, 9, 10];
const C = [1, 2, 3, 4, 1];

const checkIfSorted = (arr: number[], L: number): boolean => {
  if (L === 0) return true;
  else if (arr[L - 1] <= arr[L - 2]) return false;
  else return checkIfSorted(arr, L - 1);
};

const A_is_sorted = checkIfSorted(A, A.length);
const B_is_sorted = checkIfSorted(B, B.length);
const C_is_sorted = checkIfSorted(C, C.length);

Print(A_is_sorted);
Print(B_is_sorted);
Print(C_is_sorted);
```

```terminal
true
false
false
```

### Increasing and Decreasing Print

Print the numbers 1 to 𝑛 recursively in decreasing and increasing order.

```rust
const print = (n: number) => {
  const printFrom = (m: number) => {
    if (m === 0) return;
    else {
      Print(m);
      printFrom(m - 1);
    }
  };
  const printTo = (m: number) => {
    if (m === 0) {
      return;
    } else {
      printTo(m - 1);
      Print(m);
    }
  };
  printFrom(n);
  printTo(n);
};

print(5);
```

```terminal
5 4 3 2 1
1 2 3 4 5
```

### Recursive Power

Write a function that finds the power of number. Both the number and power
are given as input.

```rust
const power = (n: number, p: number):number => {
  if (p === 0) return 1;
  else {
    return n * power(n, p - 1);
  }
}

const a2 = power(2, 2);
const b3 = power(3, 2);
const c5 = power(5, 5);
const d6 = power(8, 6);

Print(a2);
Print(b3);
Print(c5);
Print(d6);
```

```terminal
4
9
3125
262144
```

This solution runs on ${O(n).}$ We can reduce it to ${O(\lg n)}$ by
recognizing that:

$$
\begin{aligned}
  n^p &= (n^{p/2})^2 \tt{where} p \in \bb{E} \\
  n^p &= n(n^{p/2})^2 \tt{where} p \in \bb{O} \\
\end{aligned}
$$

Refactoring:

```rust
const power = (n: number, p: number): number => {
  if (p === 0) return 1;
  let subprob = power(n, p / 2);
  let subprobsq = subprob * subprob;
  if (p & 1) return n * subprobsq;
  return subprobsq;
};

const a2 = power(2, 2);
const b3 = power(3, 2);
const c5 = power(5, 5);
const d6 = power(8, 6);

Print(a2);
Print(b3);
Print(c5);
Print(d6);
```

```terminal
4
9
3125
262144
```

### Tiling

Given a ${4 \times n}$ board, and tiles of size ${4 \times 1,}$ how many ways are
there to tile the given board, using the ${4 \times 1}$ tiles? A tile can be
placed horizontally (${4 \times 1}$) or vertically (${1 \times 4}$).

For this problem, there are only two possible ways to tile: horizontally,
or vertically. If we lay a tile out vertically:

```rust
4x1 tiles

 4  <--------------->
[]
[]
[]
[]
    <---> n - 1 <--->
```

we're left with tiling a space of ${n-1.}$ If we lay the tiles out
horizontally:

```rust
1x4 tiles

     4    <---------->
  [][][][]
4 [][][][]
  [][][][]
  [][][][]
          <--- n-4 --->
```

then we must tile a space of ${n-4.}$

```rust
const waysToTile = (n: number): number => {
  if (n < 4) return 1;
  else {
    let a = waysToTile(n - 1);
    let b = waysToTile(n - 4);
    return a + b;
  }
};

const x = waysToTile(10);
Print(x);
```

```terminal
14
```

### Enumerating Possibilities

The problems below cover some basic counting problems.

> On the island of Mumble, the Mumblian alphabet has only 5 letters, and
> every word in the Mumblian language has no more than 3 letters in it. How
> many words are possible? (A word can use a letter more than once, but 0
> letters does not count as a word.)

Say the leters are:

```
{ a, b, c, d, e }
```

Then there are 5 possibilities for the first letter:

```
5
```

This can count as one word, since a word can be _at most_ three letters. It
can be two or one. 5 possibilities for the second letter (since a letter
can be used more than once)

```
5x5=25
```

and 5 possibilities for the third letter:

```
5x5x5 = 125
```

Adding them all together:

```
5+25+125=155
```

### Satisfiability

> How many pairs of positive integers ${(m,n)}$ satisfy ${m^2+n < 22?}$

The first thing to note is that we're only looking at positive integers.
Accordingly, we have:

$$
  0 < m^2 + n < 22
$$

Next, let's use an old trick:

$$
  0 < \sqrt{a} + b < 22 \\[1em]
  \tt{where}~\sqrt{a} = m ~\tt{and}~ b=n
$$

Viewed this way, we see that there aren't that many positive integers that
satisfy this inequality. We want ${\sqrt{a}}$ to be an integer, so we're
stuck with perfect squares:

```
{ 1, 2, 3, 4 }
```

So, we have:

$$
  m \in \{ 1,2,3,4 \}
$$

If ${m=1,}$ then ${n < 22-1=21.}$ Therefore, there are 20 possible choices
for ${n.}$ If ${m=2,}$ then ${n < 22-4=18.}$ This yields 17 possible
choices. When ${m=3,}$ we have ${n < 22-9=13,}$ yielding 12 possible
choices. And when ${m=4,}$ we get ${n < 22-16=6,}$ which is 5 possible
choices. Adding them all together:

```
21 + 18 + 13 + 5 = 54
```
