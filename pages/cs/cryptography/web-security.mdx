<Head>
	<title>Web Security</title>
	<meta name={`description`} content={`Notes on web security.`}/>
</Head>

# Web Security
_This note is an overview of web security._

1. [Definitions](#definitions)
2. [Network Flow](#network-flow)
	1. [Browser UI](#browser-ui)
	2. [Browser Engine](#browser-engine)
	3. [DNS Lookup](#dns-lookup)
	4. [DNS Server](#dns-server)
		1. [DNS Hijacking: Entry Points](#dns-hijacking-entry-points)
		2. [DNS Privacy](#dns-privacy)
	5. [Network Hops](#network-hops)
	6. [Server Acceptance](#server-acceptance)
	7. [Client HTTP Request](#client-http-request)
	8. [Server HTTP Response](#server-http-response)
3. [Aside: Curl](#aside-curl)
4. [The HTTP Protocol](#the-http-protocol)
	1. [Proxy Servers](#proxy-servers)
	2. [HTTP Request Headers](#http-request-headers)
	3. [HTTP Response Headers](#http-response-headers)
5. [Authority \& Authenticity](#authority--authenticity)
	1. [IP Checking](#ip-checking)
	2. [HTTP Authentication](#http-authentication)
	3. [Client Certificates](#client-certificates)
	4. [Cookies](#cookies)
		1. [Cookie Attributes](#cookie-attributes)
		2. [Raw Cookies](#raw-cookies)
		3. [Cross-site Resource Forgery](#cross-site-resource-forgery)
		4. [Signed Cookies](#signed-cookies)
	5. [Signed Cookie Limitation](#signed-cookie-limitation)
		1. [Unique Session IDs](#unique-session-ids)
		2. [JSON Web Tokens](#json-web-tokens)
6. [Problem of Ambient Authority](#problem-of-ambient-authority)
7. [Same Origin Policy](#same-origin-policy)
	1. [Setting Document Domains](#setting-document-domains)
	2. [Fragments](#fragments)
	3. [Post-messaging](#post-messaging)
8. [Web Authentication](#web-authentication)
	1. [Authentication-related Attacks](#authentication-related-attacks)
	2. [Common Authentication Mistakes](#common-authentication-mistakes)
		1. [Case Sensitivity](#case-sensitivity)
		2. [Passwords](#passwords)
	3. [Password Best Practices](#password-best-practices)
		1. [Never Store Plaintext](#never-store-plaintext)
		2. [Check Known Leaks](#check-known-leaks)
		3. [Set Password Minimums and Maximums](#set-password-minimums-and-maximums)
		4. [Watch for Hashing Limitations](#watch-for-hashing-limitations)
			1. [Rainbow Tables](#rainbow-tables)
			2. [Salting](#salting)
			3. [Password-immune Attacks](#password-immune-attacks)
			4. [Multifactor Authentication (MFA)](#multifactor-authentication-mfa)
				1. [Time-based One-time Passwords (TOTP)](#time-based-one-time-passwords-totp)
		5. [Limit Authentication Attempts](#limit-authentication-attempts)
			1. [Rate Limiters](#rate-limiters)
			2. [CAPTCHA](#captcha)
		6. [Reauthenticate for Sensitive Actions](#reauthenticate-for-sensitive-actions)
		7. [Generic Error Messages](#generic-error-messages)
		8. [Watch HTTP Status Codes](#watch-http-status-codes)
		9. [Response Discrepancy Timing](#response-discrepancy-timing)
		10. [Data Breaches](#data-breaches)
9. [Server Security](#server-security)


## Definitions
> __~definition: threat~.__ A potential event that may harm an entity.

> __~definition: vulnerability~.__ A weakness of a resource depended on by an entity.

> __~definition: exploit~.__ The methods of taking advantage of an exploit.

## Network Flow
Cutting all details, below is a general overview of what happens when we type a URL and press enter. Note that the browser engines are multithreaded applications. The renderer, however, is a single-threaded process. Thus, while the renderer will attempt to display a site as soon as possible, it must wait for external resources (e.g., CSS stylesheets and JavaScript files) to arrive if the HTML parser encounters them (hence the name _render-blocking resource_).

_Note_. The term _networker_ is nonstandard. We use it to refer to the browser's _network module_ — the browser's program that handles network connections.

1. The browser's networker executes a DNS lookup for the hostname (e.g., `example.com`) to get an IP address (`1.2.3.4`).
2. The system sends the request to the local DNS.
3. The local DNS performs a recursive solve.
4. The DNS returns the IP address.
2. The browser's networker module forks a child process with a TCP socket to the received IP address. That child process will receive bytes from port 80 (the HTTP port).
3. The browser's networker sends a handshake request to the server specified by the IP address.
4. If the server accepts: The server forks a child process with a specific port number, and sends an acknowledgment to the browser. That acknowledgment specifies which port the browser must communicate with for the remainder of the session.
5. The browser receives the request and writes to the socket a string corresponding to an HTTP request for some file ${F.}$ The bytes comprising to that string are sent to the server.
6. If the browser is authorized to read ${F,}$ the server's child process writes a string to its own socket. That string's bytes to HTTP response headers and a body (${\of{F}}$ contents).
7. The browser's networker receives the bytes, decodes them into strings, and sends the strings to the browser's _renderer_.
8. The browser renderer receives the strings and reads the MIME (Multipurpose Internet Mail Extension) type.
	- If the MIME type is `text/html`, the renderer sends the string to the HTML parser.
		1. The HTML parser reads the strings and outputs DOM nodes (structs designed under the Document Object Model). 
		2. If the parser encounters external resources—e.g., `style.css` (a CSS file) or `app.js` (a JavaScript file)—the renderer notifies the engine, the engine notifies the networker, and steps (1) through (7) are repeated.
		3. The DOM nodes are sent to the renderer, which builds the _content tree_ (the HTML document's logical structure).
		4. For DOM nodes with a display property (e.g., a `ParagraphNode` but not the `HTMLNode`), the renderer also builds a _render tree_ — a tree where each node represents a rectangle and visual attributes. The attributes have default values, overwritten by inline-styles and CSS style sheets.
	- If the MIME type is `application/javascript`, the renderer sends the string to the JavaScript engine.
		- The JavaScript engine interprets the JavaScript code.
	- If the MIME type is `text/css`, the renderer sends the string to the CSS parser.
9. The renderer executes the _layout process_ — each node in the render tree is given exact coordinates to appear on the screen.
10. The renderer traverses the render tree, and using each node's data, executes a _paint method_, prompting the system to manipulate pixels within the browser tab currently in view. To the user, this appears as the site requested.

### Browser UI 
Billy opens a new tab on his web browser, clicks the address bar, and types `caltech.edu`. Billy hits enter.

### Browser Engine
The browser takes this URL and parses Billy's input string. Checks are made: If the string includes `https`, then this is an HTTP request. If the string is just `http`, warn Billy that they're attempting to communicate over an unsecure connection. Here, Billy's string makes no specification, so the hypothetical browser defaults to `https`.

### DNS Lookup
The browser engine takes the parsed string and executes a `getaddrinfo` call, corresponding to a DNS lookup.

```
struct addrinfo *lookup_host(char* host_name, char* port) {
	struct addrinfo *server;
	struct addrinfo hints;
	memset(&hints, 0, sizeof(hints));
	hints.ai_family = AF_UNSPEC;
	hints._ai_socktype = SOCK_STREAM;
	int rv = getaddrinfo(host_name, port_name, &hints, &server);
	if (rv != 0) {
		printf("getaddrinfo failed: %s\n", gai_strerror(rv));
		return NULL;
	}
	return server;
}
...
lookup_host("https://www.caltech.edu", "80");
```
When the kernel sees that there's data to send to the network interface, it first checks if the requested data is cached. If it is, it immediately returns the data. Otherwise, it sends the bytes comprising the lookup request to the network interface. The network interface recognizes the request as a UDP packet, so it sends the bytes immediately without restriction. Assume the data isn't cached.

### DNS Server
The request gets to Billy's closest DNS host (the _local DNS_), and the host's machine takes the request. The DNS sees `https://www.caltech.edu` and executes a _DNS recursive solver_ — an API method that sends queries to servers elsewhere. First, the DNS checks if `caltech.edu` exists in its _root nameserver_, the DNS server's default server. There is no such name, so the DNS server asks the `.com` nameserver. Again there is no such name. The server finally asks the `caltech.edu` nameserver. This server does respond and returns the corresponding address. Why does the DNS make all these calls? Because the DNS cannot possibly hold every domain name — there are anywhere between 300 to 370 million names, with many of those names mapping to multiple IP addresses.

~vulnerabilities~. Because the bytes send to and from DNS servers are UDP segments, they can easily be intercepted. Moreover, because UDP is a connectionless protocol, once the segments are intercepted, an attacker can take the segments, specify a different IP address, and return it to Billy's computer. This is a form of __*packet sniffing*__, and it applies to all packets that travel along a wireless medium. Alternatively, the attacker can change DNS records, such that every IP address returned points to the attacker's chosen server. This kind of attack is called __*DNS hijacking*__. The malicious IP address might belong to a server hosting a caltech-lookalike waiting for Billy's credentials. Fortunately, Caltech uses HTTPS—a protocol where the browser requires a particular bytestream to serve as proof of identity—which ensures that Billy's computer communicates with the real `caltech.edu`.

#### DNS Hijacking: Entry Points 
An attacker can perform a DNS hijack at several entry points:

1. Insert malware modifying DNS cachaes in Billy's machine. 
2. Modify/attack the DNS resolver's instructions — trigger buffer or stack overflows, change pointers, etc.
3. Attack the router itself; the IP addresses are correct, but the router is forwarding packets elsewhere.
4. Attack a DNS nameserver — change just one of records.
5. Attack the company that provides the DNS server.

~remark~. DNS attacks, unfortunately, are common for public school districts. This stems from a lack of funding for IT staff. In some cases, only one person is charged with managing an entire school district. In today's world, this is tantamount to one police officer for a large town.

#### DNS Privacy 
Recursive resolvers log requests made by particular machines. I.e., every domain Billy looks up will be logged by the DNS. Originally, these logs were intended for efficiency (think memoization—store previous queries, and its faster to return the matched IP address). It's now known that ISPs sell these logs to advertising companies. Billy can prevent this by changing their DNS provider.

| DNS     | Server         | Policy                                                                                                         |
| ------- | -------------- | -------------------------------------------------------------------------------------------------------------- |
| 1.1.1.1 | Cloudflare DNS | No log sales, all logs are anonymous but logs are shared with APNIC Labs, a nonprofit internet research group. |
| 8.8.8.8 | Google DNS     | No log sales, logs deleted within 24-48 hours, permanent logs containing city and region location.             |
| 9.9.9.9 | quad9 DNS      | No log sales, all logs are anonymous.                                                                          |

### Network Hops
Back at Billy's machine, the browser engine's `caltech` tab process has been waiting for the the DNS lookup to return. Once the engine receives this stream, it sends a connection request to the IP address given by the DNS. This request is a bytestream specifying both the IP address and the port number of the receiving server process. The kernel sends this bytestream down to the network interface, which then sends it off to the LAN (local area network) provider. 

The LAN provider receives the bytestream and determines the bytes correspond to a handshake request. The LAN sees that the IP address is outside its network, so it forwards the bytestream to a MAN (metropolitan area network) provider. 

The MAN receives the bytestream and determines the bytes correspond to a handshake request. The MAN sees that the IP address is outside its network, so it must send the bytestream to a WAN (wide area network) provider.

The WAN provider receives the bytestream and determines that it must go to, say, Los Angeles, California. At this point, the WAN must make a decision: What's the fastest way to get this bytestream to LA? The WAN makes this decision with a routing table, and uses a _routing algorithm_ to determine this path (details later). For now, we assume the WAN determines the optimal path—the bytestream travels to the server along intermediary nodes.

### Server Acceptance
On caltech's side, its server is busy processing requests, with a parent process listening to its server socket. The parent process sees Billy's request, forks a child, and makes an `accept` call. This sends back to Billy's browser a handshake, as well as the port number of the recently forked child. From here on out, Billy's browser will address packets to that port number. Again the packet travels through the network, going through the same drama illustrated earlier.

### Client HTTP Request
Eventually, it gets to Billy's browser. Connection established, Billy's browser now sends an _HTTP request_ for the `index.html` file mapped to `caltech.edu`. Those requests are sent again through the socket, traveling along the network. That request arrives at the port number of the forked child process. 

### Server HTTP Response
The child process writes an _HTTP response_, then sends it back down the connection towards Billy's browser. The browser receives the `HTML` bytestream and begins parsing, building, and rendering the page onto Billy's monitor. Everytime the browser encounters a resource — e.g., `styles.css` or `app.js` — it must again write to the socket with an HTTP request for those resources.

This is a very rough picture of how data is transferred to between distant machines, with numerous details left out. The truly remarkable aspect to all of this: Everything appears to happen in less than a second.

## Aside: Curl
The ${\mo{curl} \dk url}$ shell command on Linux can be used to send HTTP requests and receive HTTP responses over the terminal. If we save the output to an HTML file (${\mo{curl} \dk url \dk \gt \dk \mo{index.html}}$) we can open the HTML file in a browser.

## The HTTP Protocol
An HTTP request is just a string

$$
	\small\lq
		\mo{GET}{filepath}\mo{HTTP/1.1}\mo{\bslash n}
		\mo{Host:}hostname\mo{\bslash n}
		\mo{User-Agent:}browserName
	\rq
$$

If we used Firefox to visit `twitter.com`, the string would represent a request with the following format:

~~~
GET / HTTP/1.1
Host: twitter.com
User-agent: Mozilla/5.0
~~~

The first line, `GET / HTTP/1.1` means: _Get this filepath using the protocol HTTP 1.1_. Recall that filepaths are just file names. The `GET` is a keyword in HTTP that tells the server process to write the contents of the file to its output socket. If we have the right to read that file, the server process writes to its socket an _HTTP response_. This is also just a string:


$$
	\small\lq
		\mo{HTTP/1.1}{status}\mo{\bslash n}
		\mo{Content-length:}{length}\mo{\bslash n}
		\mo{Content-type:}{type}\mo{\bslash n}
		\mo{Date:}{date}\mo{\bslash n}
		{body}
	\rq
$$

Using the same example of `twitter.com`, the response appears on our monitor as:

~~~
HTTP/1.1 200 OK
Content-length: 9001
Content-type: text/html; charset=UTF-8
Date: Tue, 24 Sep 2019 20:30:00 GMT
<!DOCTYPE HTML><html>...
~~~

HTTP status codes are what the client uses to determine what it should do when it receives a response. The status codes are organized generally. Where ${a}$ and ${b}$ are digits:

| ~status code~ | ~semantic~    |
| ------------- | ------------- |
| ${1ab}$       | Informational |
| ${2ab}$       | Success       |
| ${3ab}$       | Redirection   |
| ${4ab}$       | Client error  |
| ${5ab}$       | Server error  |

The most common status codes:

| ~status~ | ~semantic~                                                                                                                                              |
| -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 200      | _OK_. Nothing went wrong, everything is ok.                                                                                                             |
| 206      | _Partial Content_. Nothing went wrong, parts of the file requested sent.                                                                                |
| 301      | _Permanent Redirect_. File requested is now (and always will be) a pointer to another file, so I (the server) will send you the pointee file.           |
| 302      | _Temporary Redirect_. File requested is now a pointer to another file, so I (the server) will send you the pointee file. This may change in the future. |
| 304      | _Not Modified_. File requested wasn't modified since the last cache.                                                                                    |
| 400      | _Bad Request_. Request does not follow protocol.                                                                                                        |
| 401      | _Unauthorized_. You (the client) must provide credentials to view this file.                                                                            |
| 403      | _Forbidden_. You (the client) are not authorized to view this file.                                                                                     |
| 404      | _Not Found_. I (the server) could not find that file you (the client) requested (e.g., wrong URL).                                                      |
| 410      | _Gone_. The file you (the client) requested does not exist.                                                                                             |
| 500      | _Internal Server Error_. Something went wrong with me (the server).                                                                                     |
| 502      | _Bad Gateway_. I (the server) am a proxy server, the server I get responses from cannot be reached.                                                     |
| 503      | _Service Unavailable_. I (the server) am not available (e.g., server is overloaded or down for maintenance).                                            |
| 504      | _Gateway Timeout_. I (the server) am a proxy server, and the server I get responses from is responding too slowly.                                      |

Each of these status codes allows the client to take certain actions. The status code 206 is useful for breaking up content. I.e., if the client knows that a particular file is extremely large (perhaps from caching), then receiving a status code of 200 (the entire file) will prompt the client to break up the content. If the client receives 206, then it doesn't break up the content, since it already is broken up. The status code `301` is useful for efficiency — for future requests, the client won't bother requesting the original URL. Instead, the client will always substitute the requested URL with the redirected URL. A status code of 302, however, tells the client that the requested temporarily redirects, so the browser should always request for the original URL (since the redirect may stop). The status code 304 is also useful for efficiency. The client sends its cached version of the file to the server. The server checks this file against its own: If the cached version is the same, the server sends 304, and the client uses the cached version. Otherwise, the server returns the entire, new version of the file.

### Proxy Servers
The more users a web application obtains, the more requests the application's server must handle. And with more requests, the application requires more servers. Web applications will want clients to think that there's just one server, so they create a single client-facing server that mediates between the many servers and the client. That mediating server is called the __*proxy server*__.

### HTTP Request Headers
> __`Host.`__ The domain name of the server (e.g., `twitter.com`).

> __`User-Agent.`__ The client's browser name and operating sytem.

~remark~. The user-agent is how the server determines who is calling. This is useful for security measures. E.g., the server should allow `Googlebot` (Google's crawler for indexing pages), but probably shouldn't allow `SiteDestroyer`.

> __`Referer.`__ The webpage leading the client to the page.

~remark~. The referer allows the server to determine how the user got to the server. Note that _referer_ is misspelled (correct spelling is _referrer_). By the time HTTP's implementers noticed the misspelling, it was too late—too much code had been written using _referer_ to make the change. That said, referer is one less char value, so an argument may be made that referer _is_ the correct spelling.

> __`Cookie.`__ The cookie provided by the server on first visit (if the server maintains cookies).

> __`Referer`__. Subset of bytes requested (if client requests a range).

> __`Cache-Control`.__ Specifices whether the client wants the cached response.

> __`If-Modified-Since`.__ Only send the bytestream if its changed recently.

> __`Connection`.__ Controls the TCP socket — `keep-alive` or `close`.

~remark~. Recall that the default operation of a TCP socket on the server's side is to immediately close the socket once the request has been served. If the `keep-alive` operation is set, the connection socket used by the server's child process is kept open, maintaining a connection between the client and the server process. This is allows for better performance, but it can be used for malicious code. Remember that sockets require memory—too many sockets open, and the server is overloaded.

> __`Accept`.__ Specifies the type of content expected (`text/html`).

> __`Accept-Encoding`.__ Specifies the encoding algorithm expected (e.g., `gzip`).

> __`Accept-Language`.__ Specifies the language expected (e.g., `en`).

~example~. 

<Algo>

- __Shell Command__:
~~~
curl https://twitter.com --header "Accept-Language: es" --silent | grep JavaScript
~~~
- __Shell Output__:
~~~ 
<h1>JavaScript no está disponible.</h1>
<p>Detectamos que JavaScript está desactivado en este navegador. Activa JavaScript o cambia a un navegador compatible para seguir usando twitter.com. Puedes ver una lista de navegadores compatibles en nuestro Centro de Ayuda.</p>
~~~ 

</Algo>

### HTTP Response Headers
> __`Date`.__ When the response was set.

> __`Last-Modified`.__ When the content was last modified.

> __`Cache-Control`.__ Whether to cache the response.

> __`Expires`.__ Discard response from cache after specified date.

> __`Vary`.__ List of headers that modify the response, used by the server's cache.

> __`Set-Cookie`.__ Sets a cookie for the client.

## Authority & Authenticity
> __~definition: authority~.__ A function ${f: A \to F,}$ where ${F}$ is a set of files and ${A \subseteq \set{\tx{read}, \tx{write}, \tx{delete}, \tx{create}}.}$  If ${A = \set{\tx{read}, \tx{write}, \tx{delete}, \tx{create}},}$ then we call ${A}$ _absolute authority_.

> __~definition: superuser-user~.__ Let ${F}$ be a set of one or more files. The entity that holds absolute authority over ${F}$ is called the _superuser_. An entity that has a strict subset of absolute authority is called a _user_. An entity presenting themselves as a user is called a _requester_.

> __~definition: access control~.__ The set of conditions employed by the superuser to determine whether a requester is a user.

> __~definition: explicit authority~.__ Access control where each condition is the requester's execution of a particular procedure.

> __~definition: ambient authority~.__ Access control where each condition is a property ${P,}$ such that ${P}$ is true for the requester.

> __~definition: authorization~.__ The superuser's act of granting rights to a request.

> __~definition: authentication~.__ The superuser's procedures for proving that a requester is a user.

> __~definition: session~.__ A time interval ${S = \ix{t_i,t_f},}$ such that, for each unit of time in ${S,}$ a given requester is a user. We call ${t_i}$ the _session start_ and ${t_f}$ the _session end_.

For interprocess communications on the same machine, access control is implemented through the machine's operating system. Because web communications do not necessarily exist on the same machine, application developers must use different means. The four most common means are __*cookies*__, __*IP checking*__, __*HTTP authentication*__, and __*client certificates*__.

### IP Checking
Check if the requester's IP address exists in the list of user IP addresses. If it is, then the requester is a user.

~example~. A library's server only allowing clients on its network to access electronic journals or the library's books.

~vulnerability~. ${B}$ sets up a client on the network, and ${A}$ connects to ${B.}$

### HTTP Authentication
Server requires the requester to submit an _HTTP Authorization_ request header. If the requester fails to do so, the server returns a 401 status code.

~example~. The username-password block that pops up on the browser for some websites.

### Client Certificates
Server submits a list of clients to a third party application ${X}$ (i.e., not the server or the client). When a requester ${R}$ requests access, the request is sent to ${X,}$ which determines whether ${R}$ is a user.

~example~. Verisign is a third party application that issues and maintains certificates for document signing.

~problem~. Certification applications are expensive and opaque—it's not always clear what they're doing with user data. The server process also has no control over security; everything rests on the third-party certification application. Certification applications also make traffic analysis difficult.

### Cookies
A _cookie_ is a string isomorphic to ${k,v}$ where ${k}$ is a key and ${v}$ is a value. The key maps to a variable of the server process, and ${v}$ is the variable's value. For example, a website server might have a cookie field ${theme,}$ which sets the site's color theme (a color palette for styling). That field may have a default value of ${light}$ and an optional value ${dark.}$ If the default value is used, certain lines of CSS are served. If the user changes it to dark, different lines of CSS are served. If a server implements cookie functionality, it sends the browser an initial cookie. When the browser sends responses, it includes these cookies for the server to use. The server then watches for PUT or POST requests that potentially modify the cookies. If these modifications are found, the server returns a modified cookie for the browser to attach on subsequent requests.

By maintaining cookies for each unique session (on the browser side), the server can (1) tailor the files served according to that user's preferences, (2) persist that particular user's data overtime, while (3) remaining stateless. This is how we stay logged in on websites even when we close a tab, and how shopping carts retain their contents when we log out or shut down for the day. I.e., creating the illusion of a _stateful server_.

#### Cookie Attributes
Cookies are stored by the browser's _cookie jar_. This is database file (e.g., for Firefox, a file called `cookies.sqlite` in the its `Profiles` directory) containing domain names, and for each domain name, nonnull cookie attributes with their string-values. There are several cookie attributes that the domain's server(s) can initialize:

> __`Expires`.__ Specifies a date for when the browser should delete the cookie. If no date is provided, the cookie only exists during the browsing session (as long as the browser process is live).

~remark~. Prevailing browsers—Chrome, Firefox, and Safari—use __*session restoration*__: The browser takes liberties in storing session data. Session restoration is how we do not lose form field inputs after accidentally closing the site tab. This saves many headaches for filling long online forms, but again, presents a security issue. Best practice is to always set an `Expire` value. The long online form is bad design to begin with. Instead of having a massive form on a single page, the form should be broken down into sections, with each section mapped to a different path.

Setting the `Expire` field does not necessarily have to be a date far off into the future. Some sites default to a year from the date of the most recent login, but there's no need to be so aggressive. The cycle can be shortened to a month or a day—it entirely depends on the application's usecases.

> __`Path`.__ Scopes the HTTP `Cookie` header to a particular request path prefix. That is, the browser will only send (and later save) a cookie if the HTTP Request is for a certain path. E.g., the site may have special cookies for blind users. These cookies should not be sent and saved for non-blind users.

~remark~. The `Path` attribute should _never_ be used on security-sensitive paths. Setting `Path=/user` will match against `Path=/user/Anne`, `Path=/user/John`, and all other paths incident to `/user`.

> __`Domain`.__ Scopes the cookie to a domain broader than the domain returned by the HTTP Response's `Set-Cookie` header. E.g., `login.illinois.edu` sets a cookie for `illinois.edu`. This allows the server to use the cookie for `login.illinois.edu` in handling requests for `illinois.edu`. The alternative to achieving the same effect is maintaining a shared cookie object.

> __`Secure`.__ If the string ${\mo{Secure}}$ is included in the `Set-Cookie` string, cookies will only be transmitted to and from the server of HTTP connections.

~remark~. `Secure` should always be included in cookie transmissions. Moreover, HTTPS should be used for all client-server HTTP communications. Given how sophisticated packet sniffing and MITM (Man-in-the-middle) attacks have become today—as well as certain grey areas over the legality of sniffing free WiFi networks (it may be permissible under some circumstances)—we must have highly compelling reasons for using HTTP over HTTPS.

> __`HttpOnly`.__ Prevents a cookie from being read on the frontend through JavaScript (via `document.cookie`).


#### Raw Cookies
We call a plain text cookie ${\px{k,v}}$ without anything further, a __*raw cookie*__. Raw cookies are insecure. An attacker can simply change the value in the browser's cookie jar to either keep the user logged-in or prevent the user from logging in. The server can prevent this by using _signed cookies_.

#### Cross-site Resource Forgery 
Below is a simple server in ~nodejs~, using the ~express~ package.

<Algo>

1. __import__ ${express}$ __from__ ${\string{express}}$
2. __import__ ${cookieParser}$ __from__ ${\string{cookie-parser}}$
3. ${server}$ = ${express\px{~}}$
4. ${server \mc \tx{use}(express\mc\tx{urlencoded}\px{ \tx{extended: false} })}$
5. ${server \mc \tx{use}(cookieParser\px{~})}$
6. ${server\mc\tx{get}}$ `(`${\string{/},~}$ ${request, ~ response}$ ${\nc}$ `{`
	1. ${response\mc{\tx{cookie}}\px{\string{session}, \string{1432}, \set{\tx{httpOnly: true}} }}$
	2. ${response\mc\tx{send}\px{B}}$
7. `})`
8. ${server\mc\tx{post}}$ `(`${\string{/transfer},~}$ ${request, ~ response}$ ${\nc}$ `{`
	1. __if__ ${\px{ request\mc{\tx{cookies}}\mc{\tx{session}} \mo{===} \string{1432}}}$ `{`
		1. ${{res}.\tx{status}\px{200}}$
		2. ${\sd{\tx{code block} \dk C}}$
	2. `}`
	2. __else__ ${res \mc \tx{status} \px{401}}$
9. `})`
10. ${server.\tx{listen}\px{D}}$


</Algo>

Above, the server listens on a domain ${D.}$ It sends the bytestream ${B}$ (e.g., the contents of `index.html`) in response to ~get~ requests sent to the root path alongside a cookie containing the key-value pair ${\px{\tx{session}, \string{1432}}.}$ From line 9, a path called `/transfer` sends a 200 status code back to the client if the request's cookie header contains ${\string{1432},}$ and a 401 status code otherwise.

The user visits ${D}$ and everything works well. Then they open another tab and visit malicious site ${M,}$ containing the following HTML:

<Algo>

1. `<form` ${action\eq\lq D \rq}$ ${method\eq\lq \df{post} \rq}$ `>`
	1. `<input` ${name\eq\string{amount}}$ ${type\eq\string{hidden}}$ ${value\eq\string{1000}}$ `/>`
	2. `<input` ${name\eq\string{to}}$ ${type\eq\string{hidden}}$ ${value\eq\string{malice}}$ `/>`
	3. `<button>`${\tx{I am not a robot}}$`</button>`
2. `<form>`

</Algo>

Above, ${M}$ uses the all too common button of human verification, ${\string{I am not a robot}.}$ When the user clicks on the button above, code block ${A}$ in the server __*will execute*__. Why? Because the browser will always send the cookies with the request. Remember that cookies are stored in the browser's cookie jar. It's irrelevant that the request is being sent from a site other than ${D}$'s frontend. When the browser sees that this request must be sent to ${D,}$ it checks its cookie jar for any cookies that should be sent with the request and attaches those cookies. This is called a __*cross-site resource forgery (CSRF) attack*__.

~note~. Some browsers (e.g., Chrome) will not attach cookies to requests from sites like ${M.}$ Other browsers, however, do not have such security measures. We always assume that browsers do not implement those security measures.

#### Signed Cookies
> __~definition: signature~.__ A _signature scheme_ is a triple ${(G,S,V)}$ where ${G,}$ ${S,}$ and ${V}$ are algorithms, defined as follows:
> 
> 1. The algorithm ${G}$ takes no arguments and returns a pair of strings ${\px{p_k, s_k},}$ where ${p_k}$ is a _public key_ and ${s_k}$ is a secret key.
> 2. The algorithm ${S}$ takes a pair ${\px{s_k, x}}$ and returns a string ${t,}$ where ${x}$ is some value and ${t}$ is a string called a _tag_.
> 3. The algorithm ${V}$ takes a triple ${\px{p_k, x, t},}$ and returns ${1}$ if ${x}$ maps to ${t,}$ and ${0}$ otherwise.

> __~definition: correct signature scheme~.__ A _signature scheme_ is correct iff ${V(p_k, x, S(s_k, x)) \mapsto 1.}$

> __~definition: secure signature scheme~.__ Let ${x}$ and ${t}$ be chosen by an attacker. A _signature scheme_ is secure iff ${V(p_k, x, t) \mapsto 1}$ at most ${k}$ times, where ${k}$ is a chosen constant in ${\pint.}$

A __*signed cookie*__ is a cookie generated with a signature scheme. The procedure works as follows:

1. The client sends a handshake request on initial communication.
2. If the server accepts, it forks a child process to handle subsequent communications.
3. The child process calls the signature scheme ${G\px{~} = \px{p_k, s_k}}$ saves the resulting keys.
4. The client sends an HTTP Post request, with ${\px{\mo{username}, password}}$.
$$
\\[1em]
	\eqs{
		&\mo{POST}\bslash\mo{login}\mo{HTTP/1.1} \\
		&\mo{username}\eq{username} \\
		&\mo{password}\eq{password}
	}
$$
5. The child process validates the user. If the user is validated, proceed. Otherwise, return an HTTP response denying access.
6. The child process generates a tag: ${S(s_k,~\mo{username}) = t.}$
7. The child process returns an HTTP response with:
$$
\\[1em]
	\eqs{
		&\mo{HTTP/1.1}\dk {200} \dk \mo{OK} \\
		&\mo{Set-Cookie:} \dk \mo{username}\eq{username} \\
		&\mo{Set-Cookie:} \dk \mo{tag}\eq{t}
	}
$$

For all subsequent communications with the server, the browser includes:

$$
	\eqs{
		&\mo{GET}\dk{url}\dk\mo{HTTP/1.1} \\
		&\mo{Cookie:}\dk\mo{username}\eq{username;}\dk\mo{tag}\eq{t}
	}
$$

When the server receives a cookie with a tag ${t,}$ it calls ${V(p_k, \mo{username}, t).}$ If ${V(p_k, \mo{username}, t) = 1,}$ then no verification is required, and the user's private file is returned. Otherwise, the server denies access.


### Signed Cookie Limitation 
~example~. ${A}$ is a client and ${B}$ is a server employing signed cookies. An attacker can write a program that copies and saves to a file the first secret key ${s_k.}$ The attacker can then use that secret key ${s_k}$ on subsequent sessions, _even if the user changes their password._ Why? Because the tag ${t}$ is generated from the pair ${(s_k,x)}$ where ${s_k}$ is a secret key and ${x}$ is a value. In this case, the value is a field ${username}$ (not the value of the field, the actual key ${username}$). Remember that signatures aren't hashes. They're functions that return true or false if a particular value is signed. We can prevent this with unique session IDs.

#### Unique Session IDs 
Storing unique session IDs is one solution to the signed cookie limitation. Here, we store identifiers mapped to each authenticated use on the server, only processing requests when the request includes the identifier they were initially given. By keeping the session IDs on the server rather than the client, we prevent attackers from employing authorization data on the client side—they don't exist on the client side.

1. The web server maintains a session record in a database ${R.}$
2. When the user logs in successfully, we save to ${R}$ the record ${R\ix{n} \mapsto C,}$ where ${n}$ is some hash and ${C}$ is a string isomorphic to a cookie (which can be arbitrarily complex).
	$$
	\eqs{
		n &= \mo{vUAWivCZq1EnaRhhWMDk0p}\ldots \\
		C &= \lq \lbrace \rq \tx{cookie} \rq: \lbrace \lq \tx{httpOnly} \rq:\tx{true} \ldots \rq
	}
	$$
3. In the response, the server returns a cookie ${\px{\mo{sessionId}, n}.}$
4. When the user makes later requests (e.g., ~delete~, ~post~, ~put~, ~get~, etc.), the server authenticates the request by:
	1. Reading the ${\tx{sessionId}}$ value ${n}$ in the cookie:
	$$
		c = \tx{cookie}\mc\tx{sessionId}
	$$
	2. Querying the database:
	$$
		v = R.\tx{query}\px{\lq~\df{select} \dk \mo{*} \dk \df{from} \dk \mo{sessions} \dk \df{where} \dk \mo{sessionId} \dk \df{like} \dk c~\rq}
	$$
	3. If ${v \neq \mo{NULL},}$ then the request is authentic and the server processes the request.
	4. Else, the request is inauthentic and the server does not process the request.
	
Notice that this _does not_ involve a signed cookie. Indeed, we _never_ use signed cookies for fields like usernames and passwords. Such high-sensitivity fields should be handled with backend encryption. Signed cookies should instead be used with mid-sensitivity fields (e.g., whether to show an _Accept Cookie Policy_ popup).

#### JSON Web Tokens
Unique session IDs are the traditional approach solving the signed cookie limitations. A more recent approach is the _*JSON web token (JWT)*_. A JWT is a long string:

$$
	\string{\mo{anf8J9bUzI1Ni}\ldots}
$$

This string is an encryption of a JSON object. The JSON object represents (1) a set of key-value pairs called __*claims*__ and a __*signature*__. With encryption, the JWT ensures the object's contents aren't revealed to attackers (i.e., _protected_). With a signature, JWT ensures the object's contents aren't tampered with (i.e., _authentic_). Notice the narrow tailoring: JWTs are only useful for _authentication vulnerabilities_; they do not guard against _authorization vulnerabilities_.

## Problem of Ambient Authority
~question~. Website ${W}$ has two paths, ${W\fslash{a}}$ and ${W\fslash{b}.}$ Path ${a}$ stores cookies ${C_a,}$ and ${a}$ does not want path ${b}$ to read its cookies, so path ${b}$ sets a path attribute for its cookies: ${\mo{Path}\eq\fslash{a}.}$ Is ${C_a}$ guaranteed to be inaccessible via ${b?}$

~response~. No. Path ${b}$ can contain an `iframe` element with an `src` value of ${W\fslash{a}.}$ The cookie ${C_a}$ is now available on site ${b,}$ since ${a}$ and ${b}$ are _on the same domain_ ${W.}$

~observation~. A cookie's [path attribute](#cookie-attributes) does not guarantee that a cookie is only sent from a specific URL. Browsers default to sending cookies from the current page a user is on. Best practice is to explicitly set `path=/` (the site's root), leave it at that, and never rely on it.


~example~. The site `bank.gov/account` has access to cookies for `bank.gov`, but `bank.gov` has no access to the cookies of `bank.gov/account`.

~example~. `malum.xyz` contains the following code:

~~~
<img
	src='https://www.bank.io/widthdraw?from=bob&to=malory&amount=10000'
/>
~~~

Bob, visiting `bank.io`, is sent to `malum.xyz`. When the site loads, the browser encounters the image element above, and sends a request for the `src` value. Without any safeguards, the server processes the request: Transfer ${\cash{10~000}}$ from Bob's account to Malory's account. Malory's malicious behavior is a type of attack called a __*cross-site request forgery (CSRF)*__.

> __~definition~.__ Given a web application ${W}$ with an authenticated entity ${U,}$ an attack that causes ${U}$ to perform unwanted actions on ${W.}$

~example~. If ${U}$ is a user and ${W}$ is a bank, causing ${U}$ to unintentionally request fund transfers, email changes, etc.

~example~. If ${U}$ is a superuser or administrator of some web application ${W,}$ causing ${U}$ to unintentionally add a new administrator ${X}$ or worse, uintentionally running commands from the server.

CSRF attacks are the first point of attack for bad actors confronted with HTTPS-protected responses. I.e., CSRF attacks are effective even if the bad actor can't read the HTTP response.

## Same Origin Policy
Given two sites ${A}$ and ${B,}$ consider the set of possible actions a web application might perform using ${A}$ and ${B:}$

- ${A}$ _links_ to site ${B}$
- ${A}$ _embeds all of_ ${B}$ to itself without modifying ${B}$'s contents
- ${A}$ _embeds all of_ ${B}$ to itself _and_ modifies ${B}$'s contents
- ${A}$ _embeds some of_ ${B}$ (e.g., an image) to itself without modifying ${B}$'s contents
- ${A}$ _embeds some of_ ${B}$ (e.g., an image) to itself and modifies ${B}$'s contents
- ${A}$ _writes user input_ to ${B}$
- ${A}$ _embeds scripts_ from site ${B}$
- ${A}$ _reads user input_ to ${B}$

Some of the actions present greater security risks than others.

> __~same origin policy~.__ Let ${J_1}$ and ${J_2}$ be JavaScript execution contexts, with ${J_1}$ acting on a response ${R_1}$ from server process ${S_1}$ and ${J_2}$ acting on a response ${R_2}$ from server process ${S_2.}$ ${J_1}$ has access to ${R_2}$ and ${J_2}$ has access to ${R_1}$ if, and only if, all of the following conditions are true.
> 
> 1. ${R_1}$ and ${R_2}$ have the same protocol.
> 2. ${R_1}$ and ${R_2}$ have the same hostname.
> 3. ${R_1}$ and ${R_2}$ have the same port number.
>
> If all the conditions are true, ${J_1}$ and ${J_2}$ are of the same origin. If a site ${A}$ and a site ${B}$ are of the same origin, then:
>
> 1. ${A}$ can link to ${B.}$
> 2. ${A}$ can embed ${B.}$
> 3. ${A}$ _cannot_ embed ${B}$ _and_ modify ${B}$'s contents.
> 4. ${A}$ can submit a form to ${B.}$
> 5. ${A}$ can embed images from ${B.}$
> 6. ${A}$ can embed scripts from ${B.}$
> 7. ${A}$ _cannot_ read data from ${B.}$
> 
> ~exception~. The single exception: ${J_1}$ may submit form input to ${S_2.}$

Recall that protocol, hostname, and port number are all contained in the segment headers transmitted between client and server. The exception of form input is an artifact of the internet. Form inputs were built into the web early on, before anyone understood the decisions' consequences. By the time we saw how this feature would be abused, it was already too late — too many parts of the Internet relied on the feature.

> __~same origin policy: cookies~.__ Let ${W}$ be a site with ${n}$-subdomains ${u_1,\ldots,u_n.}$ If ${W}$ sends a cookie ${W_C}$, then every ${u_i}$ has access to ${W_C.}$ If a path ${u_i}$ sends a cookie ${C_{u_i}}$, then every other path ${u_j}$ can access to cookie ${C_{u_i},}$ but ${W}$ cannot access ${C_{u_i}.}$

### Setting Document Domains
~example~. If sites ${W\fslash{A}}$ and ${W\fslash{B}}$ share a top-level domain ${W,}$ they can agree to share one another's received responses by setting ${\tx{document}\mc\tx{domain} = W.}$ (Remember that ${A}$ and ${B}$ can't share the same responses-received if they have different protocols or different port numbers; those _cannot_ be set).

~vulnerability~. A malicious site ${X}$ can also join the agreement without ${A}$ and ${B}$ knowing. ${X,}$ too, may write: ${\tx{document}\mc\tx{domain} = W.}$

### Fragments
~example~. Sites ${A}$ and ${B}$ can communicate with one another through URL fragments. This is a gap in the same origin policy. Suppose the URL visited is:

$$
	\mo{https://site.com:5000/$a$/$b$.html?$cookie$\#$F$}
$$

Above, ${F}$ is a _fragment_. If the user clicks the URL above, the default behavior is to navigate to a part of the page. The further default behavior: If the fragment doesn't exist on the page, nothing happens. All of this default behavior can be changed: Instead of navigating, change ${F.}$ E.g., if the fragment were:

$$
	\mo{https://site.com:5000/$a$/$b$.html?$cookie$\#$0$}
$$

the user clicking the URL would increment some count:

$$
	\mo{https://site.com:5000/$a$/$b$.html?$cookie$\#$1$}
$$

Again, this does not cause the page to reload. The moment we have an ability to change some value and save changes—which is precisely what's happening above—we have a communication channel. That is _cross-origin communication_ that a browser _cannot detect_. This is encapsulated by the four files below.

<Grid cols={2}>
~~~
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge" />
	<meta name="viewport" content="width=, initial-scale=1.0" />
	<title>Child</title>
</head>
<body>
	<h1>Child: localhost: 4001</h1>
	<div></div>
	<script>
		const div = document.querySelector("div");
		setInterval(() => {
			div.textContent = decodeURIComponent(window.location.hash.slice(1));
		}, 100);
	</script>
</body>
</html>
~~~
~~~
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<title>Fragment Vulnerability</title>
</head>
<body>
<h1>Parent: localhost:4000</h1>
<input name="val" />
<iframe src="http://localhost:4001/child.html"></iframe>
<script>
	const input = document.querySelector("input");
	const iframe = document.querySelector("iframe");
	input.addEventListener("input", () => {
		iframe.src = `http://localhost:4001/child.html#${encodeURIComponent(
			input.value
		)}`;
	});
</script>
</body>
</html>
~~~

~~~
import express from "express";
import { createReadStream } from "fs";

const app = express();

const rootpath = '/';

app.get(rootpath, (request, response) => {
	createReadStream('parent.html').pipe(response);
})

app.listen(4000);
~~~
~~~
import express from "express";
import { createReadStream } from "fs";

const app = express();

app.get('/child.html', (request, response) => {
	createReadStream('child.html').pipe(response);
})


app.listen(4001);
~~~
</Grid>

### Post-messaging
The fragment gap shown in the previous example was how web developers implemented cross-origin communication. Because of how useful — and dangerous — this pattern was, browsers implemented the _postMessage API_. This API allows sites with different origins to communicate with one another securely.

## Web Authentication
__~definition: nonce~.__ A secret, unpredictable value generated by a server and transmitted to a client.

> __~validation~.__ An application's procedures for determining that a given set of data is correct.

> __~verification~.__ An application's procedures for determining that a given set of data has not been tampered with.

> __~authentication~.__ An application's procedures for proving that an entity is a user.

~example~. Login forms, HTTP cookies, HTTP authentication, client certificates are all authentication tools.

> __~user~.__ An entity authenticated by an application.

~example~. Access control lists (e.g., a database of ${\tx{user~id} \to \tx{accessible~pages}}$) and capability URLs (e.g., the unique token in a Google Docs URL) are all authorization tools.

> __~authorization~.__ An application's procedures for determining what rights to grant a user.


To _authorize_ an entity, the application must _authenticate_ the entity. Once authenticated, the entity is a user. To authenticate an entity, the application must _validate_ and _verify_ dataset submitted by the user.

~observation~. By implication, authentication requires at least one dataset to verify and validate. The classical datasets:

1. __*Knowledge*__. Datasets known by the user (e.g., a username-password combination).
2. __*Property*__. Datasets kept by the user (e.g., cryptographic keys).
3. __*Attributes*__. User attributes (e.g., a fingerprint or other biometric data).

The more datasets the application has, the more certain the application is about its authentication conclusions.

> __~definition: ${n}$-factor authentication~.__ An authentication that uses $n$ datasets for authentication is called an _${n}$-factor authentication_.

~example~. Standard ATMs require property and knowledge — the user's credit card and the user's pin. This is 2-factor authentication.

~example~. A university requiring students to log in with their `.edu` emails and passwords followed by a submitting a texted security code is a 2-factor authentication. The `.edu` email and password combination is knowledge, and the texted security code is property.

### Authentication-related Attacks
> __~brute-force~.__ Testing multiple passwords from a particular source against a single attack.

> __~credential stuffing~.__ Testing username-password pairs obtained from another application's breach. This attack is premised on the fact that users commonly recycle passwords (e.g., Bob uses one password for Netflix, Spotify, and Facebook).

> __~password spraying~.__ Testing one weak password against a large number of different accounts (e.g., trying `123456789` across different sites).

### Common Authentication Mistakes

#### Case Sensitivity
1. Usernames should be unique — no two users should have the same username.
2. Usernames should always be stored case-insensitive. I.e., before storing a username in the database, convert it entirely to lowercase. To accomodate the user's desired username with its casing, the database can include a separate column `display_name`.

~rationale~. We want usernames to be unique. Case sensitivity complicates this parameter — `alice1`, `aLice1`, `Alice1`, `ALICE1`, are all different users.

#### Passwords

> __~password entropy~.__ Given a password ${p}$ of length ${L_p}$ from an alphabet of ${n_p}$ characters, the following propositions are true:
> 
> 1. There are ${{n_p}^{L_p}}$ possible passwords.
> 2. The _entropy_ of ${P,}$ denoted ${\Xx_p}$ is defined as:
> $$
> 	\Xx_p = L_p \lg n_p.
> $$

> __~weak password axiom~.__ Given the choice, a user will always use a weak password.

To counter the weak password axiom, applications use __*password criteria*__. The software industry is flooded with recommendations on how to construct these criteria, but many of them are impractical.

__~password rotation~__. Applications can require users to change their passwords every $n$ months. The problem: Users almost always just add a number to the new password. E.g., `billy1` becomes `billy11` after $n$ months, then `billy111` after $2n$ months. The passwords now provide another piece of information: How long the user's been registered with an application.

__~composition rules~__. Some applications require users to include upper and lowercase letters, numbers, and symbols. There is really only one composition rule that should be enforced, the password length, discussed in the next section.

The minimum length ensures the bare minimum for a proper hash, and the upper limit ensures the encryption algorithm can actually work. Outside of the rule above, there really should not be any other composition rules. Why? Because there's no evidence that passwords with symbols and mixed cases fare any better than passwords that consist entirely of letters or symbols. There is, however, a large body of evidence that users will respond to password constraints by doing the bare minimum. E.g., Billy puts in `"Billy#123"` (an all too common password structure) instead of something that Billy knows and has never shared with anyone (`"I wish I went to med school"`). In fact, passwords containing multiple words from a large dictionary are known to be much stronger than passwords of a single word.

Following up, there are some practices that we should _never do today_. These were common practices in the 1990s and early-2000s when the Internet was young, but they absolutely should no longer be done:

- __Maximum length of 8-10 characters.__ Longer passwords are stronger.
- __Minimum password age policies.__ These are policies that only allow users to change their passwords $n$ times within a set time frame (e.g., you can only change your password once a week at most). If a user's password is exposed, they must be able to immediately change it. 
- __Disabling cut-and-paste.__ This completely breaks password managers that automatically generate strong passwords.
- __Password hints/Security questions.__  These are systems that provide alternative authentication via answering predefined questions. They're almost _never_ implemented with enough entropy (correct answers can be guessed in a few attempts). Because of how difficult it is to get these systems right, their risks and costs outweight their minute benefits. If a user can't remember their password, it should be reset.
- __Requiring password input on a virtual keyboard.__ This idea started when key-loggers plagued the Internet. It's misguided and entails several problems: ${\px{1}}$ It implicitly limits the password alphabet—only the characters shown on the keyboard. ${\px{2}}$ It creates an easier avenue for attack: On modern systems, it's easier to record a screen than it is to install a key-logger. ${\px{3}}$ It creates a heap of usability and accessibility issues.

### Password Best Practices

#### Never Store Plaintext
Passwords should never be stored in plaintext. Whether that's in database or (worse) a log file. This sounds obvious, but it's a far more common violation than most would think. At one point, Facebook and Twitter logged ~http~ requests to analyze security issues. Ironically, those log files were vulnerabilities that attackers took advantage of—they contained password submissions. Only password hashes should be stored.

#### Check Known Leaks
Passwords should be checked against known leaked passwords. When a user submits their password, check against another database for known leaks. If the submitted password is known leak, inform the user and instruct them to submit a different password. We want to check against these leaks because these are the first source attackers look to for guesses.

#### Set Password Minimums and Maximums
A password should be at least 8 characters long, with a maximum of at least 64 characters. _Do not allow unlimited length passwords_. Unlimited password lengths present an opportunity for a __*password denial-of-service (PDoS) attack*__. The PDoS is a varianet of the _long string DoS_: A string that's so long that the backend's hashing function causes a stack or heap overflow.

| Password Length | Time to Crack |
| --------------- | ------------- |
| 9 characters    | 2 minutes     |
| 10 characters   | 2 hours       |
| 11 characters   | 6 days        |
| 12 characters   | 1 year        |
| 13 characters   | 64 years      |

#### Watch for Hashing Limitations
This is a practice that's all too often overlooked because of developer tendencies to simply use libraries blindly. ~bcrypt~, for example, is one of the most popular libraries for hashing passwords. But it's deeply limited: It only works for ASCII characters, and can only process passwords at most 72 characters in lenghth. Anymore than 72, and ~bcrypt~ chops off the rest of the string. This is called __*silent truncation*__. Applications should process passwords as is, length and unicode.

For web applications, a hash function ${H}$ should be selected based on the following criteria:

1. ${H}$ should be strongly invertible (i.e., difficult to go from ciphertext to plaintext).
2. ${H}$ should be deterministic — the same message always results in the same hash.
3. ${H}$ should be slow to compute. Slower hashing algorithms will slow down attackers.
4. ${H}$ should have few collisions — it's infeasible to find different messages with the same hash value.
5. ${H}$ should have avalanche effects — small changes to messages result in wildly different hashes.

##### Rainbow Tables
Simply hashing isn't enough. Suppose a site ${W}$ uses ~sha256~ to hash passwords. ~sha256~ is a fairly fast hasher. And because of how fast it is, an attacker can perform the following:

1. Construct a table of the most common passwords or leaked passwords, alongside their ~sha256~ hashes. This is called a __*rainbow table*__.
2. Compare those hashes with ${W}$'s hashes.
3. Because ideal hash functions are deterministic, if the attacker finds matches with their table (perhaps through a simple linear search), it's trivial to determine which users have which passwords.

##### Salting
Password hashes should always be _salted_. A __*salt*__ is a fixed-length cryptographically-strong random value. The salt is usually 16, 32, or 64 bytes. The salt and the password are concatenated before they're hashed. To ensure the user can login later, the password and the salt sit next to one another in the database:

~~~
import crypto from "crypto"

function sha256(s) {
	crypto.createHash('sha256').update(s).digest('base64');
}

const salt = crypto.randomBytes(16).toString('base64');
const passwordHash = sha256(salt + password);
const user = await createUser(username, salt, passwordHash);

// handle login

const otherPasswordHash = sha256(salt + otherPassword);
const isValid = otherPasswordHash === passwordHash;
~~~

The ~bcrypt~ library makes this easier (but recall its limitations):

~~~
import bcrypt from "bcrypt";

const HASH_ROUNDS = 10; // sets how long the hash should run

const passwordHash = bcrypt.hashSync(password, HASH_ROUNDS);
const user = await createUser(username, passwordHash);

// handle login
const isValid = bcrypt.compareSync(otherPassword, passwordHash);
~~~

##### Password-immune Attacks
There are a number of attacks that cannot be prevented with passwords:

- Credential stuffing
- Phishing
- Keystroke logging
- Local discovery
- Extortion

Passwords can prevent these attacks:

- Password spraying
- Brute force

##### Multifactor Authentication (MFA)
Attacks that circumvent passwords can be minimized with multifactor authentication (e.g., send a secret key to the user's email or phone to log in). If user experience is a concern, we can limit MFA to:

- new browser/device or IP address
- unusual country or location
- IP address appears on known blocklists
- IP address has tried to log in to multiple accounts
- A login attempt that appears to be scripted rather than manual

Why is MFA so prevalent today? One reason is because of a blog post by Alex Weinert at Microsoft (~your password doesn't matter~, 2019). In short, Microsoft researchers determined that over ${70\%}$ of the passwords in a given database with millions of records can be broken using a machine worth ${\cash{20~000}}$ and known leaks. 

###### Time-based One-time Passwords (TOTP)
Below is the general workflow for a TOTP:

1. The server creates a secret key for the user requesting authentication.
2. The server shares the secret key with an application ${A}$ on the user's end (e.g., their email or phone).
3. ${A}$ starts a timer upon receipt.
4. ${A}$ generates a password using the secret key and the counter.
5. ${A}$ changes the counter after a fixed time (usually 30 seconds) and regenerates the one-time password.

We can see this workflow in action on mobile applications like ~duo~.

#### Limit Authentication Attempts
Users should not have an unlimited number of register/login attempts. Unlimited attempts provide a straight route to _password brute-force attacks_ (guessing passwords until they land on the right one) and _denial-of-service (DoS) attacks (sending so many requests that the servers crash)_.

##### Rate Limiters
The standard response for too many authentication attempts: Temporarily ban the user. The ~express~ package for Node servers provides a middleware called ~ratelimiter~, which ensures that there aren't too many attempts for a given username. 

##### CAPTCHA 
Another approach is to use a __*Completely Automated Public Turing Test (~captcha~)*__. This differentiates between computers and humans through a reverse Turing test. The old tests uses funny-looking characters, but a paper by Greg Mori from UC Berkeley (~recognizing objects in adversarial clutter: breaking a visual captcha~) showed that ~captcha~s have a breakage rate of ${33\%,}$ and since they almost always allow multiple attempts, the ${33\%}$ is more than enough for an attacker to circumvent the guard. Moreover, recent developments in machine learning have shown that all text-based ~captchas~ can be broken. This is why the more common ~captchas~ today are either: ${\px{1}}$ _image ~captcha~s_ or ${\px{2}}$ re~captcha~ — ~captchas~ that use mouse movements, time to answer, and trust scores (built over time for a particular ~ip~ address) to differentiate (the familiar "I am not a robot" checkbox).

~captchas~, however, present their own problems:

- On average, it takes users 10 seconds to solve a ~captcha~.
- Image ~captchas~ will not work for visually-impaired users. Remember that applications must still comply with accessibility laws. This means that the application must also implement an audio ~captcha~, which must be equally secure as the visual implementation.
- Image ~captchas~ can be worked around: The attacker takes a screen shot of the ~captcha~ on the target site ${A,}$ and presents it to the users of another site ${B.}$ The user's inputs n site ${B}$ are then submitted as responses to site ${A.}$
- There are implicit ethical concerns. Attackers can pay dark market firms employing humans that solve ~captchas~. These prices go as low as fifty cents for a thousand ~captcha~ solves. The humans solving these ~captchas~ are generally impoverished workers in Asia, South America, and Africa.
- Because re~captchas~ build trust scores for IP addresses, they inherently discriminate against users that use VPNs or TOR.

#### Reauthenticate for Sensitive Actions
Changing passwords, emails, adding a new shipping address, or deleting an account are all sensitive actions. Users should be required to enter their current password before executing them.

#### Generic Error Messages
While error responses are necessary for development, they should not be used in production.

~example~. If a user incorrectly enters their password, do not tell them that they incorrectly entered their password. Same goes for username and email. Informing the user that no account exists with a particular username or email are all pieces of information useful for an attack. Just give a generic error message: _Invalid username or password._

~example~. For registration, do not inform users that an email or username is already in use. Either use a generic error message or send an activation link to the email.

#### Watch HTTP Status Codes
Invalid credentials _should always_ be responded with an HTTP 400.

#### Response Discrepancy Timing
Always keep authentication code on one branch. If authentication consists of multiple branches, attackers can time how long it takes to go from one branch to another. Longer times indicate that a particular user doesn't exist.

#### Data Breaches 
Some common mistakes that lead to data breaches:

- Accidentally leaving an S3 bucket public.
- Forgetting to set passwords on databases.
- Neglecting .gitignore files and accidentally pushing sensitive information to Github.

## Designing Servers
Some standards to follow when writing server code:

__~reduce complexity~.__ Complexity is the enemy of security. The more components the server has, the more complex it is.

__~verify assumptions~.__ If we make assumptions about code execution, verify them up front. Expecting a string argument? Check its type. Expecting a number less than 10? Run a comparison. Languages like JavaScript do not perform type checking, and Typescript does not perform type-checking at runtime.

__~fail immediatiely~.__ If an assumption is violated, the code should fail immediately. Do not work past the failure. The Robustness Principle—ensuring that systems continue working despite failure—may be appropriate for life-critical systems, but it does not apply to web servers.

__~polymorphic functions~.__ Functions that decide what to do based on the type or number of arguments passed are almost always doing too many different things. When it comes to servers, functions should only do one thing, and do it well.

### Warning on Express
~example~. Node's ~express~ module uses a construct called _middleware._ The syntactic structure:

~~~
// Middleware A
function A(req, res, next) {
	// code
	next();
}
// Middleware B
function B(req, res, next, error) {
	// code
}
...
app.use(A)
app.use(B)
...
app.get("/", (req, res)=>{
	// A runs
	// B runs
	res.status(...)
})
app.post("/", (req, res)=>{ 
	// A runs
	// B runs
	res.status(...)
})
~~~

In short, they're functions that will always run when an ~express~ server instance receives a request. The middleware's `req` parameter will use the `req` argument passed to the instance method call, and the `res` paramer to the `res` argument. The `next` parameter is a callback function (e.g., after `A` runs, call `next`) built into the ~express~ router. It tells ~express~ to pass control to the next middleware. This is necessary if we want middleware `B` to execute. Otherwise, control isn't passed to `B` and `B` never executes.

The error argument is where problems come up. If any one middleware has a fourth argument (e.g., `B`), then `B` becomes an error-handling middleware. If an exception occurs in any of the `app.use` handlers, then ~express~ will look for the first `app.use` with a 4-argument handler and call that handler. _This is extremely dangerous behavior_.