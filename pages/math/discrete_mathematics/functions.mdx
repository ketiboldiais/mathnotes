import { Plot } from "../../../components/illus/components/Plot/Plot";
import { Plot3D } from "../../../components/illus/components/Plot3D/Plot3D";

<head>
	<title>Functions</title>
	<description>Notes on functions.</description>
</head>

# Functions

1. [Non-functions](#non-functions)
2. [Image](#image)
3. [Types of Functions](#types-of-functions)
	1. [Onto Functions](#onto-functions)
	2. [One-to-one Functions](#one-to-one-functions)
4. [Functions in Discrete Mathematics](#functions-in-discrete-mathematics)

Here is a simple function, called ${f}$:

<Bipartite
	data={[
		{ link: ["a", "2"] },
		{ link: ["b", "2"] },
		{ link: ["c", "5"] },
		{ link: ["4"] },
	]}
	scale={60}
	height={170}
	marginTop={0}
	marginBottom={0}
	groups={["A", "B"]}
	id={"function1"}
/>

Above, ${A}$ is called ùëì's **domain** and ${B}$ is ùëì's **codomain**. The
domain is the set of all possible inputs of ùëì, and the codomain is the set
of all possible outputs of ùëì. Based on the diagram above, the only possible
inputs of ùëì are ùëé, ùëè, and ùëê, and the only possible outputs of ùëì are 2, 4,
and 5.

## Non-functions

Consider the following mapping:

<Bipartite
	data={[
		{ link: ["a", "2"] },
		{ link: ["b", "2"] },
		{ link: ["c", "5"] },
		{ link: ["4"] },
	]}
	scale={40}
	reverseArrows={true}
	height={170}
	marginTop={0}
	marginBottom={0}
	groups={["\\text{codomain}", "\\text{domain}"]}
	id={"nonFunction1"}
/>

In this chapter, the mapping above is _not_ considered a function. This is
because the input ${2}$ returns multiple outputs, and the input ${4}$
doesn't return any output value. In other areas of mathematics, these types
of relations have various names like _partial functions_. We'll consider
these "functions" in later sections, but for now, we will not consider them
functions.

The mappings below aren't functions either:

<Grid cols={2}>

<Bipartite
	data={[{ link: ["b", "2"] }, { link: ["b", "3"] }, { link: ["g", "4"] }]}
	scale={70}
	height={170}
	marginTop={0}
	marginBottom={0}
	groups={["\\text{domain}", "\\text{codomain}"]}
	id={"nonFunction2"}
	caption={"\\text{Relation 1}"}
/>

<Bipartite
	data={[
		{ link: ["b", "2"] },
		{ link: ["g", "3"] },
		{ link: ["r", { id: "v", hide: true }] },
	]}
	scale={70}
	height={170}
	marginTop={0}
	marginBottom={0}
	groups={["\\text{domain}", "\\text{codomain}"]}
	id={"nonFunction3"}
	caption={"\\text{Relation 2}"}
/>
</Grid>

Relation 1 has one input returning two elements, and relation 2 has one
input that returning nothing.

## Image

If we look at the function above, we see that the function yields only two
values, 2 and 5. These two outputs comprise ùëì's **image**. A function's
image is the set of all outputs that the function actually produces. From
this definition, it follows that a function's image is a subset of its
codomain.

## Types of Functions

Functions are a subset of relations. And within the set of all functions,
there are various types of functions. We examine each of these types of
functions below.

### Onto Functions

Onto functions are best defined in terms of what functions _aren't_ onto
functions. The functions below are _not_ onto functions:

<Grid cols={2}>

<Bipartite
	data={[{ link: ["a", "2"] }, { link: ["b", "3"] }, { link: ["4"] }]}
	scale={70}
	height={170}
	marginTop={0}
	marginBottom={0}
	groups={["\\text{domain}", "\\text{codomain}"]}
	id={"not_onto1"}
	caption={"\\text{Relation A}"}
/>

<Bipartite
	data={[
		{ link: ["b", "2"] },
		{ link: ["g", "3"] },
		{ link: ["r", { id: "v", hide: true }] },
	]}
	scale={70}
	reverseArrows={true}
	height={170}
	marginTop={0}
	marginBottom={0}
	groups={["\\text{codomain}", "\\text{domain}"]}
	id={"not_onto2"}
	caption={"\\text{Relation B}"}
/>
</Grid>

For a function to be considered an onto function, _all_ members of its
domain must produce _all_ members of its codomain. Above, Relation A is not
an onto function because one member of its codomain ‚Äî the element 4 ‚Äî is
not returned by an input. Relation B is not a function at all.

### One-to-one Functions

Like onto functions, one-to-one functions are best explained in terms of
what they aren't. These relations are _not_ one-to-one functions:

<Grid cols={2}>
<Bipartite
	data={[
		{ link: ["a", "1"] },
		{ link: ["b", "2"] },
		{ link: ["c", "1"] },
	]}
	scale={70}
	height={170}
	marginTop={0}
	marginBottom={0}
	groups={["\\text{domain}", "\\text{codomain}"]}
	id={"not_1_to_1_a"}
	caption={"\\text{Relation C}"}
/>

<Bipartite
	data={[
		{ link: ["a", "1"] },
		{ link: ["b", "2"] },
		{ link: ["c", "1"] },
	]}
	scale={70}
	reverseArrows={true}
	height={170}
	marginTop={0}
	marginBottom={0}
	groups={["\\text{codomain}", "\\text{domain}"]}
	id={"not_1_to_1_b"}
	caption={"\\text{Relation D}"}
/>
</Grid>

Relation C is not a one-to-one function because it has two inputs producing
the same output. Relation D is not a one-to-one function because it isn't a
function in the first place.

## Functions in Discrete Mathematics

Coming from a background in calculus or real analysis, it's often tempting
to "fix" functions ‚Äî i.e., make them easier to work with or to force them
into a particular definition ‚Äî by adjusting the domain or codomain. This
often works well in continuous mathematics, but not so much in discrete
mathematics.

For example, the square root function, ${f(x) = \sqrt{x},}$ can be thought
of as having two output values: real number outputs and complex number
outputs.

<Plot3D
	functions={[
		{
			f: (x, y) => Math.sqrt(x),
			domain: [-10, 10],
			range: [-10, 10],
			scale: 30,
		},
		{
			f: (x, y) => -Math.sqrt(x),
			domain: [-10, 10],
			range: [-10, 10],
			scale: 20,
		},
	]}
	width={400}
	height={400}
	scale={60}
	yaw={0.3}
	pitch={0.2}
/>

Imagining the plot of ${f(x) = \sqrt{x}}$ as the plot above is convenient
from a real or complex analysis perspective, but it's not exactly
convenient when we're working with computers. Why? Because (1) computers
can't work with the notion of infinity as we normally would in pure
mathematics, and (2) codomains of functions are often awkward, if not
difficult, to describe.

For example, consider the output of some function in C. The return type of
that function is fairly restrictive ‚Äî we have ints, floats, booleans, char
arrays, and so on. What we don't have are real numbers with complex
components, as the graph above visualizes. In fact, the graph above is
rendered with floating point numbers and a bit of trigonometry.

To drive this point further, consider an example from computer graphics.
Suppose we want to render some 2-dimensional Euclidean shape. To do so, we
need a function that outputs Cartesian coordinates ‚Äî an ordered pair of the
form ${(x,y).}$ Depending on what our renderer will do, the function might
be defined as follows:

```nasm
float f(double a): [float, float] {
	float x = 2 * a;
	float y = (4*a) + 10;
	return [x, y]
}
```

From a mathematical perspective, this function takes the form:

$$
	f: \RR \to \RR^2,~~f(a) = (2a, 4a+10)
$$

The notation ${f: \RR \to \RR^2}$ is called the function's _type signature_.
This is the mathematical equivalent of a _function type declaration_ we see
in statically-typed languages like ML, C, C++, Java, Rust, or TypeScript.
The symbol ${\RR}$ tells us that the function ${f}$ has a domain of real
number inputs, and the symbol ${\RR^2}$ tells us that the function has a
codomain of pairs of real numbers. The image of this function is the set of
all inputs of the form ${(2a, 4a+10).}$ Or, in set notation:

$$
	\text{Img}(f) = \{ (x,y) \in \RR : y = 2x + 5 \}
$$

If we plot the function above (${y = 2x + 5}$), we get:

<Plot 
	functions={[
		{f: (x) => 2*x + 5, color: "var(--red)"}
	]}
	scale={60}
	id={"geometry_demo"}
/>
